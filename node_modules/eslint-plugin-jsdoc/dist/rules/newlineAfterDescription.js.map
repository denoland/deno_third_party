{"version":3,"sources":["../../src/rules/newlineAfterDescription.js"],"names":["jsdoc","report","context","jsdocNode","sourceCode","indent","always","description","tags","length","_","has","options","descriptionEndsWithANewline","source","slice","startsWith","sourceLines","getText","split","lastDescriptionLine","findLastIndex","line","replace","last","fixer","splice","replaceText","join","iterateAllJsdocs","meta","fixable","schema","enum","type"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport iterateJsdoc from '../iterateJsdoc';\n\nexport default iterateJsdoc(({\n  jsdoc,\n  report,\n  context,\n  jsdocNode,\n  sourceCode,\n  indent,\n}) => {\n  let always;\n\n  if (!jsdoc.description || !jsdoc.tags.length) {\n    return;\n  }\n\n  if (_.has(context.options, 0)) {\n    always = context.options[0] === 'always';\n  } else {\n    always = true;\n  }\n\n  // The contents of the jsdoc.source and of jsdoc.description is left trimmed.\n  // The contents of the jsdoc.description is right trimmed.\n  // This gets the text following the description.\n  const descriptionEndsWithANewline = jsdoc.source.slice(jsdoc.description.length).startsWith('\\n\\n');\n\n  if (always) {\n    if (!descriptionEndsWithANewline) {\n      const sourceLines = sourceCode.getText(jsdocNode).split('\\n');\n      const lastDescriptionLine = _.findLastIndex(sourceLines, (line) => {\n        return line.replace(/^\\s*\\*\\s*/, '') === _.last(jsdoc.description.split('\\n'));\n      });\n      report('There must be a newline after the description of the JSDoc block.', (fixer) => {\n        // Add the new line\n        sourceLines.splice(lastDescriptionLine + 1, 0, `${indent} *`);\n\n        return fixer.replaceText(jsdocNode, sourceLines.join('\\n'));\n      }, {\n        line: lastDescriptionLine,\n      });\n    }\n  } else if (descriptionEndsWithANewline) {\n    const sourceLines = sourceCode.getText(jsdocNode).split('\\n');\n    const lastDescriptionLine = _.findLastIndex(sourceLines, (line) => {\n      return line.replace(/^\\s*\\*\\s*/, '') === _.last(jsdoc.description.split('\\n'));\n    });\n    report('There must be no newline after the description of the JSDoc block.', (fixer) => {\n      // Remove the extra line\n      sourceLines.splice(lastDescriptionLine + 1, 1);\n\n      return fixer.replaceText(jsdocNode, sourceLines.join('\\n'));\n    }, {\n      line: lastDescriptionLine + 1,\n    });\n  }\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    fixable: 'whitespace',\n    schema: [\n      {\n        enum: ['always', 'never'],\n        type: 'string',\n      },\n    ],\n    type: 'layout',\n  },\n});\n"],"file":"newlineAfterDescription.js"}