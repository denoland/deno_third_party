"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* barrel:ignore */
var typescript_1 = require("../typescript");
var utils_1 = require("../utils");
var errors = require("../errors");
var DocumentRegistry = /** @class */ (function () {
    function DocumentRegistry(fileSystemWrapper) {
        this.fileSystemWrapper = fileSystemWrapper;
        this.sourceFileCacheByFilePath = new utils_1.KeyValueCache();
    }
    DocumentRegistry.prototype.removeSourceFile = function (fileName) {
        this.sourceFileCacheByFilePath.removeByKey(fileName);
    };
    DocumentRegistry.prototype.createOrUpdateSourceFile = function (fileName, compilationSettings, scriptSnapshot) {
        var sourceFile = this.sourceFileCacheByFilePath.get(fileName);
        if (sourceFile == null)
            sourceFile = this.updateSourceFile(fileName, compilationSettings, scriptSnapshot, DocumentRegistry.initialVersion);
        else
            sourceFile = this.updateSourceFile(fileName, compilationSettings, scriptSnapshot, this.getNextSourceFileVersion(sourceFile));
        return sourceFile;
    };
    DocumentRegistry.prototype.acquireDocument = function (fileName, compilationSettings, scriptSnapshot, version, scriptKind) {
        var sourceFile = this.sourceFileCacheByFilePath.get(fileName);
        if (sourceFile == null || this.getSourceFileVersion(sourceFile) !== version)
            sourceFile = this.updateSourceFile(fileName, compilationSettings, scriptSnapshot, version);
        return sourceFile;
    };
    DocumentRegistry.prototype.acquireDocumentWithKey = function (fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {
        // ignore the key because we only ever keep track of one key
        return this.acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);
    };
    DocumentRegistry.prototype.updateDocument = function (fileName, compilationSettings, scriptSnapshot, version, scriptKind) {
        // the compiler will call this even when it doesn't need to update for some reason
        return this.acquireDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);
    };
    DocumentRegistry.prototype.updateDocumentWithKey = function (fileName, path, compilationSettings, key, scriptSnapshot, version, scriptKind) {
        // ignore the key because we only ever keep track of one key
        return this.updateDocument(fileName, compilationSettings, scriptSnapshot, version, scriptKind);
    };
    DocumentRegistry.prototype.getKeyForCompilationSettings = function (settings) {
        return "defaultKey";
    };
    DocumentRegistry.prototype.releaseDocument = function (fileName, compilationSettings) {
        // ignore, handled by removeSourceFile
    };
    DocumentRegistry.prototype.releaseDocumentWithKey = function (path, key) {
        // ignore, handled by removeSourceFile
    };
    DocumentRegistry.prototype.reportStats = function () {
        throw new errors.NotImplementedError();
    };
    DocumentRegistry.prototype.getSourceFileVersion = function (sourceFile) {
        return sourceFile.version || "0";
    };
    DocumentRegistry.prototype.getNextSourceFileVersion = function (sourceFile) {
        var currentVersion = parseInt(this.getSourceFileVersion(sourceFile), 10) || 0;
        return (currentVersion + 1).toString();
    };
    DocumentRegistry.prototype.updateSourceFile = function (fileName, compilationSettings, scriptSnapshot, version) {
        fileName = this.fileSystemWrapper.getStandardizedAbsolutePath(fileName);
        var newSourceFile = this.createCompilerSourceFile(fileName, scriptSnapshot, compilationSettings, version);
        this.sourceFileCacheByFilePath.set(fileName, newSourceFile);
        return newSourceFile;
    };
    DocumentRegistry.prototype.createCompilerSourceFile = function (fileName, scriptSnapshot, compilationSettings, version) {
        var scriptTarget = compilationSettings.target || typescript_1.ScriptTarget.Latest;
        return typescript_1.ts.createLanguageServiceSourceFile(fileName, scriptSnapshot, scriptTarget, version, true, /* scriptKind */ undefined);
    };
    DocumentRegistry.initialVersion = "0";
    return DocumentRegistry;
}());
exports.DocumentRegistry = DocumentRegistry;
