"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var errors = require("../../../../errors");
var utils_1 = require("../../../../utils");
function RenameableNode(Base) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.rename = function (newName, options) {
            this.context.languageService.renameNode(getNodeToRename(this), newName, options);
            return this;
            function getNodeToRename(thisNode) {
                if (utils_1.TypeGuards.isIdentifier(thisNode))
                    return thisNode;
                else if (thisNode.getNameNode != null) {
                    var node = thisNode.getNameNode();
                    errors.throwIfNullOrUndefined(node, "Expected to find a name node when renaming.");
                    if (utils_1.TypeGuards.isArrayBindingPattern(node) || utils_1.TypeGuards.isObjectBindingPattern(node))
                        throw new errors.NotImplementedError("Not implemented renameable scenario for " + node.getKindName() + ".");
                    return node;
                }
                else
                    throw new errors.NotImplementedError("Not implemented renameable scenario for " + thisNode.getKindName());
            }
        };
        return class_1;
    }(Base));
}
exports.RenameableNode = RenameableNode;
