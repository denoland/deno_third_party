"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var errors = require("../../../errors");
var manipulation_1 = require("../../../manipulation");
var typescript_1 = require("../../../typescript");
var utils_1 = require("../../../utils");
var callBaseSet_1 = require("../callBaseSet");
var callBaseGetStructure_1 = require("../callBaseGetStructure");
function ModuledNode(Base) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.addImportDeclaration = function (structure) {
            return this.addImportDeclarations([structure])[0];
        };
        class_1.prototype.addImportDeclarations = function (structures) {
            var imports = this.getImportDeclarations();
            var insertIndex = imports.length === 0 ? 0 : imports[imports.length - 1].getChildIndex() + 1;
            return this.insertImportDeclarations(insertIndex, structures);
        };
        class_1.prototype.insertImportDeclaration = function (index, structure) {
            return this.insertImportDeclarations(index, [structure])[0];
        };
        class_1.prototype.insertImportDeclarations = function (index, structures) {
            var _this = this;
            return this._insertChildren({
                expectedKind: typescript_1.SyntaxKind.ImportDeclaration,
                index: index,
                structures: structures,
                write: function (writer, info) {
                    _this._standardWrite(writer, info, function () {
                        _this.context.structurePrinterFactory.forImportDeclaration().printTexts(writer, structures);
                    }, {
                        previousNewLine: function (previousMember) { return utils_1.TypeGuards.isImportDeclaration(previousMember); },
                        nextNewLine: function (nextMember) { return utils_1.TypeGuards.isImportDeclaration(nextMember); }
                    });
                }
            });
        };
        class_1.prototype.getImportDeclaration = function (conditionOrModuleSpecifier) {
            return utils_1.ArrayUtils.find(this.getImportDeclarations(), getCondition());
            function getCondition() {
                if (typeof conditionOrModuleSpecifier === "string")
                    return function (dec) { return dec.getModuleSpecifierValue() === conditionOrModuleSpecifier; };
                else
                    return conditionOrModuleSpecifier;
            }
        };
        class_1.prototype.getImportDeclarationOrThrow = function (conditionOrModuleSpecifier) {
            return errors.throwIfNullOrUndefined(this.getImportDeclaration(conditionOrModuleSpecifier), "Expected to find an import with the provided condition.");
        };
        class_1.prototype.getImportDeclarations = function () {
            return this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.ImportDeclaration);
        };
        class_1.prototype.addExportDeclaration = function (structure) {
            return this.addExportDeclarations([structure])[0];
        };
        class_1.prototype.addExportDeclarations = function (structures) {
            // always insert at end of module because of export {Identifier}; statements
            return this.insertExportDeclarations(this.getChildSyntaxListOrThrow().getChildCount(), structures);
        };
        class_1.prototype.insertExportDeclaration = function (index, structure) {
            return this.insertExportDeclarations(index, [structure])[0];
        };
        class_1.prototype.insertExportDeclarations = function (index, structures) {
            var _this = this;
            return this._insertChildren({
                expectedKind: typescript_1.SyntaxKind.ExportDeclaration,
                index: index,
                structures: structures,
                write: function (writer, info) {
                    _this._standardWrite(writer, info, function () {
                        _this.context.structurePrinterFactory.forExportDeclaration().printTexts(writer, structures);
                    }, {
                        previousNewLine: function (previousMember) { return utils_1.TypeGuards.isExportDeclaration(previousMember); },
                        nextNewLine: function (nextMember) { return utils_1.TypeGuards.isExportDeclaration(nextMember); }
                    });
                }
            });
        };
        class_1.prototype.getExportDeclaration = function (conditionOrModuleSpecifier) {
            return utils_1.ArrayUtils.find(this.getExportDeclarations(), getCondition());
            function getCondition() {
                if (typeof conditionOrModuleSpecifier === "string")
                    return function (dec) { return dec.getModuleSpecifierValue() === conditionOrModuleSpecifier; };
                else
                    return conditionOrModuleSpecifier;
            }
        };
        class_1.prototype.getExportDeclarationOrThrow = function (conditionOrModuleSpecifier) {
            return errors.throwIfNullOrUndefined(this.getExportDeclaration(conditionOrModuleSpecifier), "Expected to find an export declaration with the provided condition.");
        };
        class_1.prototype.getExportDeclarations = function () {
            return this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.ExportDeclaration);
        };
        class_1.prototype.addExportAssignment = function (structure) {
            return this.addExportAssignments([structure])[0];
        };
        class_1.prototype.addExportAssignments = function (structures) {
            // always insert at end of file because of export {Identifier}; statements
            return this.insertExportAssignments(this.getChildSyntaxListOrThrow().getChildCount(), structures);
        };
        class_1.prototype.insertExportAssignment = function (index, structure) {
            return this.insertExportAssignments(index, [structure])[0];
        };
        class_1.prototype.insertExportAssignments = function (index, structures) {
            var _this = this;
            return this._insertChildren({
                expectedKind: typescript_1.SyntaxKind.ExportAssignment,
                index: index,
                structures: structures,
                write: function (writer, info) {
                    _this._standardWrite(writer, info, function () {
                        _this.context.structurePrinterFactory.forExportAssignment().printTexts(writer, structures);
                    }, {
                        previousNewLine: function (previousMember) { return utils_1.TypeGuards.isExportAssignment(previousMember); },
                        nextNewLine: function (nextMember) { return utils_1.TypeGuards.isExportAssignment(nextMember); }
                    });
                }
            });
        };
        class_1.prototype.getExportAssignment = function (condition) {
            return utils_1.ArrayUtils.find(this.getExportAssignments(), condition);
        };
        class_1.prototype.getExportAssignmentOrThrow = function (condition) {
            return errors.throwIfNullOrUndefined(this.getExportAssignment(condition), "Expected to find an export assignment with the provided condition.");
        };
        class_1.prototype.getExportAssignments = function () {
            return this.getChildSyntaxListOrThrow().getChildrenOfKind(typescript_1.SyntaxKind.ExportAssignment);
        };
        class_1.prototype.getDefaultExportSymbol = function () {
            var sourceFileSymbol = this.getSymbol();
            // will be undefined when the module doesn't have an export
            if (sourceFileSymbol == null)
                return undefined;
            return sourceFileSymbol.getExportByName("default");
        };
        class_1.prototype.getDefaultExportSymbolOrThrow = function () {
            return errors.throwIfNullOrUndefined(this.getDefaultExportSymbol(), "Expected to find a default export symbol");
        };
        class_1.prototype.getExportSymbols = function () {
            var symbol = this.getSymbol();
            return symbol == null ? [] : this.context.typeChecker.getExportsOfModule(symbol);
        };
        class_1.prototype.getExportedDeclarations = function () {
            var exportSymbols = this.getExportSymbols();
            return utils_1.ArrayUtils.from(getDeclarationsForSymbols());
            function getDeclarationsForSymbols() {
                function getDeclarationHandlingImportsAndExports(declaration) {
                    function getDeclarationsForSymbol(symbol) {
                        var e_4, _a, _b, _c, d, e_4_1;
                        return tslib_1.__generator(this, function (_d) {
                            switch (_d.label) {
                                case 0:
                                    if (symbol == null)
                                        return [2 /*return*/];
                                    _d.label = 1;
                                case 1:
                                    _d.trys.push([1, 6, 7, 8]);
                                    _b = tslib_1.__values(symbol.getDeclarations()), _c = _b.next();
                                    _d.label = 2;
                                case 2:
                                    if (!!_c.done) return [3 /*break*/, 5];
                                    d = _c.value;
                                    return [5 /*yield**/, tslib_1.__values(getDeclarationHandlingImportsAndExports(d))];
                                case 3:
                                    _d.sent();
                                    _d.label = 4;
                                case 4:
                                    _c = _b.next();
                                    return [3 /*break*/, 2];
                                case 5: return [3 /*break*/, 8];
                                case 6:
                                    e_4_1 = _d.sent();
                                    e_4 = { error: e_4_1 };
                                    return [3 /*break*/, 8];
                                case 7:
                                    try {
                                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                    }
                                    finally { if (e_4) throw e_4.error; }
                                    return [7 /*endfinally*/];
                                case 8: return [2 /*return*/];
                            }
                        });
                    }
                    var e_3, _a, _b, _c, d, e_3_1, identifier, identifier, symbol, identifier, symbol;
                    return tslib_1.__generator(this, function (_d) {
                        switch (_d.label) {
                            case 0:
                                if (handledDeclarations.has(declaration))
                                    return [2 /*return*/];
                                handledDeclarations.add(declaration);
                                if (!utils_1.TypeGuards.isExportSpecifier(declaration)) return [3 /*break*/, 9];
                                _d.label = 1;
                            case 1:
                                _d.trys.push([1, 6, 7, 8]);
                                _b = tslib_1.__values(declaration.getLocalTargetDeclarations()), _c = _b.next();
                                _d.label = 2;
                            case 2:
                                if (!!_c.done) return [3 /*break*/, 5];
                                d = _c.value;
                                return [5 /*yield**/, tslib_1.__values(getDeclarationHandlingImportsAndExports(d))];
                            case 3:
                                _d.sent();
                                _d.label = 4;
                            case 4:
                                _c = _b.next();
                                return [3 /*break*/, 2];
                            case 5: return [3 /*break*/, 8];
                            case 6:
                                e_3_1 = _d.sent();
                                e_3 = { error: e_3_1 };
                                return [3 /*break*/, 8];
                            case 7:
                                try {
                                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                }
                                finally { if (e_3) throw e_3.error; }
                                return [7 /*endfinally*/];
                            case 8: return [3 /*break*/, 17];
                            case 9:
                                if (!utils_1.TypeGuards.isExportAssignment(declaration)) return [3 /*break*/, 11];
                                identifier = declaration.getExpression();
                                if (identifier == null || identifier.getKind() !== typescript_1.SyntaxKind.Identifier)
                                    return [2 /*return*/];
                                return [5 /*yield**/, tslib_1.__values(getDeclarationsForSymbol(identifier.getSymbol()))];
                            case 10:
                                _d.sent();
                                return [3 /*break*/, 17];
                            case 11:
                                if (!utils_1.TypeGuards.isImportSpecifier(declaration)) return [3 /*break*/, 13];
                                identifier = declaration.getNameNode();
                                symbol = identifier.getSymbol();
                                if (symbol == null)
                                    return [2 /*return*/];
                                return [5 /*yield**/, tslib_1.__values(getDeclarationsForSymbol(symbol.getAliasedSymbol()))];
                            case 12:
                                _d.sent();
                                return [3 /*break*/, 17];
                            case 13:
                                if (!(declaration.getKind() === typescript_1.SyntaxKind.ImportClause)) return [3 /*break*/, 15];
                                identifier = declaration.getNodeProperty("name");
                                if (identifier == null)
                                    return [2 /*return*/];
                                symbol = identifier.getSymbol();
                                if (symbol == null)
                                    return [2 /*return*/];
                                return [5 /*yield**/, tslib_1.__values(getDeclarationsForSymbol(symbol.getAliasedSymbol()))];
                            case 14:
                                _d.sent();
                                return [3 /*break*/, 17];
                            case 15: return [4 /*yield*/, declaration];
                            case 16:
                                _d.sent();
                                _d.label = 17;
                            case 17: return [2 /*return*/];
                        }
                    });
                }
                var e_1, _a, e_2, _b, handledDeclarations, exportSymbols_1, exportSymbols_1_1, symbol, _c, _d, declaration, e_2_1, e_1_1;
                return tslib_1.__generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            handledDeclarations = utils_1.createHashSet();
                            _e.label = 1;
                        case 1:
                            _e.trys.push([1, 12, 13, 14]);
                            exportSymbols_1 = tslib_1.__values(exportSymbols), exportSymbols_1_1 = exportSymbols_1.next();
                            _e.label = 2;
                        case 2:
                            if (!!exportSymbols_1_1.done) return [3 /*break*/, 11];
                            symbol = exportSymbols_1_1.value;
                            _e.label = 3;
                        case 3:
                            _e.trys.push([3, 8, 9, 10]);
                            _c = tslib_1.__values(symbol.getDeclarations()), _d = _c.next();
                            _e.label = 4;
                        case 4:
                            if (!!_d.done) return [3 /*break*/, 7];
                            declaration = _d.value;
                            return [5 /*yield**/, tslib_1.__values(getDeclarationHandlingImportsAndExports(declaration))];
                        case 5:
                            _e.sent();
                            _e.label = 6;
                        case 6:
                            _d = _c.next();
                            return [3 /*break*/, 4];
                        case 7: return [3 /*break*/, 10];
                        case 8:
                            e_2_1 = _e.sent();
                            e_2 = { error: e_2_1 };
                            return [3 /*break*/, 10];
                        case 9:
                            try {
                                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                            }
                            finally { if (e_2) throw e_2.error; }
                            return [7 /*endfinally*/];
                        case 10:
                            exportSymbols_1_1 = exportSymbols_1.next();
                            return [3 /*break*/, 2];
                        case 11: return [3 /*break*/, 14];
                        case 12:
                            e_1_1 = _e.sent();
                            e_1 = { error: e_1_1 };
                            return [3 /*break*/, 14];
                        case 13:
                            try {
                                if (exportSymbols_1_1 && !exportSymbols_1_1.done && (_a = exportSymbols_1.return)) _a.call(exportSymbols_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                            return [7 /*endfinally*/];
                        case 14: return [2 /*return*/];
                    }
                });
            }
        };
        class_1.prototype.removeDefaultExport = function (defaultExportSymbol) {
            defaultExportSymbol = defaultExportSymbol || this.getDefaultExportSymbol();
            if (defaultExportSymbol == null)
                return this;
            var declaration = defaultExportSymbol.getDeclarations()[0];
            if (declaration.compilerNode.kind === typescript_1.SyntaxKind.ExportAssignment)
                manipulation_1.removeChildrenWithFormatting({ children: [declaration], getSiblingFormatting: function () { return manipulation_1.FormattingKind.Newline; } });
            else if (utils_1.TypeGuards.isModifierableNode(declaration)) {
                declaration.toggleModifier("default", false);
                declaration.toggleModifier("export", false);
            }
            return this;
        };
        class_1.prototype.set = function (structure) {
            callBaseSet_1.callBaseSet(Base.prototype, this, structure);
            if (structure.imports != null) {
                this.getImportDeclarations().forEach(function (d) { return d.remove(); });
                this.addImportDeclarations(structure.imports);
            }
            if (structure.exports != null) {
                this.getExportDeclarations().forEach(function (d) { return d.remove(); });
                this.addExportDeclarations(structure.exports);
            }
            return this;
        };
        class_1.prototype.getStructure = function () {
            // do not get the imports and exports... instead let StatementedNode return the body text
            return callBaseGetStructure_1.callBaseGetStructure(Base.prototype, this, {});
        };
        return class_1;
    }(Base));
}
exports.ModuledNode = ModuledNode;
