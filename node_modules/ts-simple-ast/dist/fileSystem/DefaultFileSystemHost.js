"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var nodePath = require("path");
var errors = require("../errors");
var utils_1 = require("../utils");
var DefaultFileSystemHost = /** @class */ (function () {
    function DefaultFileSystemHost() {
        // Prevent "fs-extra" and "globby" from being loaded in environments that don't support it (ex. browsers).
        // This means if someone specifies to use a virtual file system then it won't load this.
        this.fs = require("fs-extra");
        this.globby = require("globby");
    }
    DefaultFileSystemHost.prototype.delete = function (path) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.fs.unlink(path, function (err) {
                if (err)
                    reject(_this.getFileNotFoundErrorIfNecessary(err, path));
                else
                    resolve();
            });
        });
    };
    DefaultFileSystemHost.prototype.deleteSync = function (path) {
        try {
            this.fs.unlinkSync(path);
        }
        catch (err) {
            throw this.getFileNotFoundErrorIfNecessary(err, path);
        }
    };
    DefaultFileSystemHost.prototype.readDirSync = function (dirPath) {
        try {
            return this.fs.readdirSync(dirPath).map(function (name) { return utils_1.FileUtils.pathJoin(dirPath, name); });
        }
        catch (err) {
            throw this.getDirectoryNotFoundErrorIfNecessary(err, dirPath);
        }
    };
    DefaultFileSystemHost.prototype.readFile = function (filePath, encoding) {
        var _this = this;
        if (encoding === void 0) { encoding = "utf-8"; }
        return new Promise(function (resolve, reject) {
            _this.fs.readFile(filePath, encoding, function (err, data) {
                if (err)
                    reject(_this.getFileNotFoundErrorIfNecessary(err, filePath));
                else
                    resolve(data);
            });
        });
    };
    DefaultFileSystemHost.prototype.readFileSync = function (filePath, encoding) {
        if (encoding === void 0) { encoding = "utf-8"; }
        try {
            return this.fs.readFileSync(filePath, encoding);
        }
        catch (err) {
            throw this.getFileNotFoundErrorIfNecessary(err, filePath);
        }
    };
    DefaultFileSystemHost.prototype.writeFile = function (filePath, fileText) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {
                            _this.fs.writeFile(filePath, fileText, function (err) {
                                if (err)
                                    reject(err);
                                else
                                    resolve();
                            });
                        })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    DefaultFileSystemHost.prototype.writeFileSync = function (filePath, fileText) {
        this.fs.writeFileSync(filePath, fileText);
    };
    DefaultFileSystemHost.prototype.mkdir = function (dirPath) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var err_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.fs.mkdirp(dirPath)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        err_1 = _a.sent();
                        // ignore if it already exists
                        if (err_1.code !== "EEXIST")
                            throw err_1;
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    DefaultFileSystemHost.prototype.mkdirSync = function (dirPath) {
        try {
            this.fs.mkdirpSync(dirPath);
        }
        catch (err) {
            // ignore if it already exists
            if (err.code !== "EEXIST")
                throw err;
        }
    };
    DefaultFileSystemHost.prototype.move = function (srcPath, destPath) {
        return this.fs.move(srcPath, destPath, { overwrite: true });
    };
    DefaultFileSystemHost.prototype.moveSync = function (srcPath, destPath) {
        this.fs.moveSync(srcPath, destPath, { overwrite: true });
    };
    DefaultFileSystemHost.prototype.copy = function (srcPath, destPath) {
        return this.fs.copy(srcPath, destPath, { overwrite: true });
    };
    DefaultFileSystemHost.prototype.copySync = function (srcPath, destPath) {
        this.fs.copySync(srcPath, destPath, { overwrite: true });
    };
    DefaultFileSystemHost.prototype.fileExists = function (filePath) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.fs.stat(filePath, function (err, stat) {
                if (err)
                    resolve(false);
                else
                    resolve(stat.isFile());
            });
        });
    };
    DefaultFileSystemHost.prototype.fileExistsSync = function (filePath) {
        try {
            return this.fs.statSync(filePath).isFile();
        }
        catch (err) {
            return false;
        }
    };
    DefaultFileSystemHost.prototype.directoryExists = function (dirPath) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.fs.stat(dirPath, function (err, stat) {
                if (err)
                    resolve(false);
                else
                    resolve(stat.isDirectory());
            });
        });
    };
    DefaultFileSystemHost.prototype.directoryExistsSync = function (dirPath) {
        try {
            return this.fs.statSync(dirPath).isDirectory();
        }
        catch (err) {
            return false;
        }
    };
    DefaultFileSystemHost.prototype.getCurrentDirectory = function () {
        return utils_1.FileUtils.standardizeSlashes(nodePath.resolve());
    };
    DefaultFileSystemHost.prototype.glob = function (patterns) {
        return this.globby.sync(patterns, {
            cwd: this.getCurrentDirectory(),
            absolute: true
        });
    };
    DefaultFileSystemHost.prototype.getDirectoryNotFoundErrorIfNecessary = function (err, path) {
        return utils_1.FileUtils.isNotExistsError(err) ? new errors.DirectoryNotFoundError(path) : err;
    };
    DefaultFileSystemHost.prototype.getFileNotFoundErrorIfNecessary = function (err, path) {
        return utils_1.FileUtils.isNotExistsError(err) ? new errors.FileNotFoundError(path) : err;
    };
    return DefaultFileSystemHost;
}());
exports.DefaultFileSystemHost = DefaultFileSystemHost;
