"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const node_1 = require("../typeguard/node");
function endsControlFlow(statement) {
    return getControlFlowEnd(statement).end;
}
exports.endsControlFlow = endsControlFlow;
const defaultControlFlowEnd = { statements: [], end: false };
function getControlFlowEnd(statement) {
    return node_1.isBlockLike(statement) ? handleBlock(statement) : getControlFlowEndWorker(statement);
}
exports.getControlFlowEnd = getControlFlowEnd;
function getControlFlowEndWorker(statement) {
    switch (statement.kind) {
        case ts.SyntaxKind.ReturnStatement:
        case ts.SyntaxKind.ThrowStatement:
        case ts.SyntaxKind.ContinueStatement:
        case ts.SyntaxKind.BreakStatement:
            return { statements: [statement], end: true };
        case ts.SyntaxKind.Block:
            return handleBlock(statement);
        case ts.SyntaxKind.ForStatement:
        case ts.SyntaxKind.WhileStatement:
            return handleForAndWhileStatement(statement);
        case ts.SyntaxKind.ForOfStatement:
        case ts.SyntaxKind.ForInStatement:
            return handleForInOrOfStatement(statement);
        case ts.SyntaxKind.DoStatement:
            return matchBreakOrContinue(getControlFlowEndWorker(statement.statement), node_1.isBreakOrContinueStatement);
        case ts.SyntaxKind.IfStatement:
            return handleIfStatement(statement);
        case ts.SyntaxKind.SwitchStatement:
            return matchBreakOrContinue(handleSwitchStatement(statement), node_1.isBreakStatement);
        case ts.SyntaxKind.TryStatement:
            return handleTryStatement(statement);
        case ts.SyntaxKind.LabeledStatement:
            return matchLabel(getControlFlowEndWorker(statement.statement), statement.label);
        case ts.SyntaxKind.WithStatement:
            return getControlFlowEndWorker(statement.statement);
        default:
            return defaultControlFlowEnd;
    }
}
function handleBlock(statement) {
    const result = { statements: [], end: false };
    for (const s of statement.statements) {
        const current = getControlFlowEndWorker(s);
        result.statements.push(...current.statements);
        if (current.end) {
            result.end = true;
            break;
        }
    }
    return result;
}
function handleForInOrOfStatement(statement) {
    const end = matchBreakOrContinue(getControlFlowEndWorker(statement.statement), node_1.isBreakOrContinueStatement);
    end.end = false;
    return end;
}
function handleForAndWhileStatement(statement) {
    const constantCondition = statement.kind === ts.SyntaxKind.WhileStatement
        ? getConstantCondition(statement.expression)
        : statement.condition === undefined || getConstantCondition(statement.condition);
    if (constantCondition === false)
        return defaultControlFlowEnd;
    const end = matchBreakOrContinue(getControlFlowEndWorker(statement.statement), node_1.isBreakOrContinueStatement);
    if (constantCondition === undefined)
        end.end = false;
    return end;
}
function getConstantCondition(node) {
    switch (node.kind) {
        case ts.SyntaxKind.TrueKeyword:
            return true;
        case ts.SyntaxKind.FalseKeyword:
            return false;
        default:
            return;
    }
}
function handleIfStatement(node) {
    switch (getConstantCondition(node.expression)) {
        case true:
            return getControlFlowEndWorker(node.thenStatement);
        case false:
            return node.elseStatement === undefined
                ? defaultControlFlowEnd
                : getControlFlowEndWorker(node.elseStatement);
    }
    const then = getControlFlowEndWorker(node.thenStatement);
    if (node.elseStatement === undefined)
        return {
            statements: then.statements,
            end: false,
        };
    const elze = getControlFlowEndWorker(node.elseStatement);
    return {
        statements: [...then.statements, ...elze.statements],
        end: then.end && elze.end,
    };
}
function handleSwitchStatement(node) {
    let hasDefault = false;
    const result = {
        statements: [],
        end: false,
    };
    for (const clause of node.caseBlock.clauses) {
        if (clause.kind === ts.SyntaxKind.DefaultClause)
            hasDefault = true;
        const current = handleBlock(clause);
        result.end = current.end;
        result.statements.push(...current.statements);
    }
    if (!hasDefault)
        result.end = false;
    return result;
}
function handleTryStatement(node) {
    let finallyResult;
    if (node.finallyBlock !== undefined) {
        finallyResult = handleBlock(node.finallyBlock);
        if (finallyResult.end)
            return finallyResult;
    }
    const tryResult = handleBlock(node.tryBlock);
    if (node.catchClause === undefined)
        return { statements: finallyResult.statements.concat(tryResult.statements), end: tryResult.end };
    const catchResult = handleBlock(node.catchClause.block);
    return {
        statements: tryResult.statements
            .filter((s) => s.kind !== ts.SyntaxKind.ThrowStatement)
            .concat(catchResult.statements, finallyResult === undefined ? [] : finallyResult.statements),
        end: tryResult.end && catchResult.end,
    };
}
function matchBreakOrContinue(current, pred) {
    const result = {
        statements: [],
        end: current.end,
    };
    for (const statement of current.statements) {
        if (pred(statement) && statement.label === undefined) {
            result.end = false;
            continue;
        }
        result.statements.push(statement);
    }
    return result;
}
function matchLabel(current, label) {
    const result = {
        statements: [],
        end: current.end,
    };
    const labelText = label.text;
    for (const statement of current.statements) {
        switch (statement.kind) {
            case ts.SyntaxKind.BreakStatement:
            case ts.SyntaxKind.ContinueStatement:
                if (statement.label !== undefined && statement.label.text === labelText) {
                    result.end = false;
                    continue;
                }
        }
        result.statements.push(statement);
    }
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udHJvbC1mbG93LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29udHJvbC1mbG93LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsaUNBQWlDO0FBQ2pDLDRDQUE4RjtBQUU5RixTQUFnQixlQUFlLENBQUMsU0FBc0M7SUFDbEUsT0FBTyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDNUMsQ0FBQztBQUZELDBDQUVDO0FBaUJELE1BQU0scUJBQXFCLEdBQW1CLEVBQUMsVUFBVSxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFDLENBQUM7QUFFM0UsU0FBZ0IsaUJBQWlCLENBQUMsU0FBc0M7SUFDcEUsT0FBTyxrQkFBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLHVCQUF1QixDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ2hHLENBQUM7QUFGRCw4Q0FFQztBQUVELFNBQVMsdUJBQXVCLENBQUMsU0FBdUI7SUFDcEQsUUFBUSxTQUFTLENBQUMsSUFBSSxFQUFFO1FBQ3BCLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUM7UUFDbkMsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsQ0FBQztRQUNsQyxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUM7UUFDckMsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWM7WUFDN0IsT0FBTyxFQUFDLFVBQVUsRUFBRSxDQUF1QixTQUFTLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFDLENBQUM7UUFDdEUsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLEtBQUs7WUFDcEIsT0FBTyxXQUFXLENBQVcsU0FBUyxDQUFDLENBQUM7UUFDNUMsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQztRQUNoQyxLQUFLLEVBQUUsQ0FBQyxVQUFVLENB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