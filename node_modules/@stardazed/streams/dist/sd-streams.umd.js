(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.sdStreams = {}));
}(this, function (exports) { 'use strict';

	/**
	* @stardazed/streams - implementation of the web streams standard
	* Part of Stardazed
	* (c) 2018-Present by Arthur Langereis - @zenmumbler
	* https://github.com/stardazed/sd-streams
	*/

	const state_ = Symbol("state_");
	const storedError_ = Symbol("storedError_");
	function isInteger(value) {
	    if (!isFinite(value)) {
	        return false;
	    }
	    const absValue = Math.abs(value);
	    return Math.floor(absValue) === absValue;
	}
	function isFiniteNonNegativeNumber(value) {
	    if (!(typeof value === "number" && isFinite(value))) {
	        return false;
	    }
	    return value >= 0;
	}
	function isAbortSignal(signal) {
	    if (typeof signal !== "object" || signal === null) {
	        return false;
	    }
	    try {
	        const aborted = Object.getOwnPropertyDescriptor(AbortSignal.prototype, "aborted").get;
	        aborted.call(signal);
	        return true;
	    }
	    catch (err) {
	        return false;
	    }
	}
	function invokeOrNoop(o, p, args) {
	    const method = o[p];
	    if (method === undefined) {
	        return undefined;
	    }
	    return Function.prototype.apply.call(method, o, args);
	}
	function cloneArrayBuffer(srcBuffer, srcByteOffset, srcLength, cloneConstructor) {
	    return srcBuffer.slice(srcByteOffset, srcByteOffset + srcLength);
	}
	function transferArrayBuffer(buffer) {
	    return buffer.slice(0);
	}
	function copyDataBlockBytes(toBlock, toIndex, fromBlock, fromIndex, count) {
	    new Uint8Array(toBlock, toIndex, count).set(new Uint8Array(fromBlock, fromIndex, count));
	}
	const objectCloneMemo = new WeakMap();
	let sharedArrayBufferSupported_;
	function supportsSharedArrayBuffer() {
	    if (sharedArrayBufferSupported_ === undefined) {
	        try {
	            new SharedArrayBuffer(16);
	            sharedArrayBufferSupported_ = true;
	        }
	        catch (e) {
	            sharedArrayBufferSupported_ = false;
	        }
	    }
	    return sharedArrayBufferSupported_;
	}
	function cloneValue(value) {
	    const valueType = typeof value;
	    switch (valueType) {
	        case "number":
	        case "string":
	        case "boolean":
	        case "undefined":
	        case "bigint":
	            return value;
	        case "object": {
	            if (objectCloneMemo.has(value)) {
	                return objectCloneMemo.get(value);
	            }
	            if (value === null) {
	                return value;
	            }
	            if (value instanceof Date) {
	                return new Date(value.valueOf());
	            }
	            if (value instanceof RegExp) {
	                return new RegExp(value);
	            }
	            if (supportsSharedArrayBuffer() && value instanceof SharedArrayBuffer) {
	                return value;
	            }
	            if (value instanceof ArrayBuffer) {
	                const cloned = cloneArrayBuffer(value, 0, value.byteLength, ArrayBuffer);
	                objectCloneMemo.set(value, cloned);
	                return cloned;
	            }
	            if (ArrayBuffer.isView(value)) {
	                const clonedBuffer = cloneValue(value.buffer);
	                let length;
	                if (value instanceof DataView) {
	                    length = value.byteLength;
	                }
	                else {
	                    length = value.length;
	                }
	                return new value.constructor(clonedBuffer, value.byteOffset, length);
	            }
	            if (value instanceof Map) {
	                const clonedMap = new Map();
	                objectCloneMemo.set(value, clonedMap);
	                value.forEach((v, k) => clonedMap.set(k, cloneValue(v)));
	                return clonedMap;
	            }
	            if (value instanceof Set) {
	                const clonedSet = new Map();
	                objectCloneMemo.set(value, clonedSet);
	                value.forEach((v, k) => clonedSet.set(k, cloneValue(v)));
	                return clonedSet;
	            }
	            const clonedObj = {};
	            objectCloneMemo.set(value, clonedObj);
	            const sourceKeys = Object.getOwnPropertyNames(value);
	            for (const key of sourceKeys) {
	                clonedObj[key] = cloneValue(value[key]);
	            }
	            return clonedObj;
	        }
	        case "symbol":
	        case "function":
	        default:
	            throw new DOMException("Uncloneable value in stream", "DataCloneError");
	    }
	}
	function promiseCall(f, v, args) {
	    try {
	        const result = Function.prototype.apply.call(f, v, args);
	        return Promise.resolve(result);
	    }
	    catch (err) {
	        return Promise.reject(err);
	    }
	}
	function createAlgorithmFromUnderlyingMethod(obj, methodName, extraArgs) {
	    const method = obj[methodName];
	    if (method === undefined) {
	        return () => Promise.resolve(undefined);
	    }
	    if (typeof method !== "function") {
	        throw new TypeError(`Field "${methodName}" is not a function.`);
	    }
	    return function (...fnArgs) {
	        return promiseCall(method, obj, fnArgs.concat(extraArgs));
	    };
	}
	function validateAndNormalizeHighWaterMark(hwm) {
	    const highWaterMark = Number(hwm);
	    if (isNaN(highWaterMark) || highWaterMark < 0) {
	        throw new RangeError("highWaterMark must be a valid, non-negative integer.");
	    }
	    return highWaterMark;
	}
	function makeSizeAlgorithmFromSizeFunction(sizeFn) {
	    if (typeof sizeFn !== "function" && typeof sizeFn !== "undefined") {
	        throw new TypeError("size function must be undefined or a function");
	    }
	    return function (chunk) {
	        if (typeof sizeFn === "function") {
	            return sizeFn(chunk);
	        }
	        return 1;
	    };
	}
	var ControlledPromiseState;
	(function (ControlledPromiseState) {
	    ControlledPromiseState[ControlledPromiseState["Pending"] = 0] = "Pending";
	    ControlledPromiseState[ControlledPromiseState["Resolved"] = 1] = "Resolved";
	    ControlledPromiseState[ControlledPromiseState["Rejected"] = 2] = "Rejected";
	})(ControlledPromiseState || (ControlledPromiseState = {}));
	function createControlledPromise() {
	    const conProm = {
	        state: ControlledPromiseState.Pending
	    };
	    conProm.promise = new Promise(function (resolve, reject) {
	        conProm.resolve = function (v) { conProm.state = ControlledPromiseState.Resolved; resolve(v); };
	        conProm.reject = function (e) { conProm.state = ControlledPromiseState.Rejected; reject(e); };
	    });
	    return conProm;
	}

	const CHUNK_SIZE = 16384;
	class QueueImpl {
	    constructor() {
	        this.chunks_ = [[]];
	        this.readChunk_ = this.writeChunk_ = this.chunks_[0];
	        this.length_ = 0;
	    }
	    push(t) {
	        this.writeChunk_.push(t);
	        this.length_ += 1;
	        if (this.writeChunk_.length === CHUNK_SIZE) {
	            this.writeChunk_ = [];
	            this.chunks_.push(this.writeChunk_);
	        }
	    }
	    front() {
	        if (this.length_ === 0) {
	            return undefined;
	        }
	        return this.readChunk_[0];
	    }
	    shift() {
	        if (this.length_ === 0) {
	            return undefined;
	        }
	        const t = this.readChunk_.shift();
	        this.length_ -= 1;
	        if (this.readChunk_.length === 0 && this.readChunk_ !== this.writeChunk_) {
	            this.chunks_.shift();
	            this.readChunk_ = this.chunks_[0];
	        }
	        return t;
	    }
	    get length() {
	        return this.length_;
	    }
	}

	const queue_ = Symbol("queue_");
	const queueTotalSize_ = Symbol("queueTotalSize_");
	function dequeueValue(container) {
	    const pair = container[queue_].shift();
	    const newTotalSize = container[queueTotalSize_] - pair.size;
	    container[queueTotalSize_] = Math.max(0, newTotalSize);
	    return pair.value;
	}
	function enqueueValueWithSize(container, value, size) {
	    if (!isFiniteNonNegativeNumber(size)) {
	        throw new RangeError("Chunk size must be a non-negative, finite numbers");
	    }
	    container[queue_].push({ value, size });
	    container[queueTotalSize_] += size;
	}
	function peekQueueValue(container) {
	    return container[queue_].front().value;
	}
	function resetQueue(container) {
	    container[queue_] = new QueueImpl();
	    container[queueTotalSize_] = 0;
	}

	const controlledReadableStream_ = Symbol("controlledReadableStream_");
	const pullAlgorithm_ = Symbol("pullAlgorithm_");
	const cancelAlgorithm_ = Symbol("cancelAlgorithm_");
	const strategySizeAlgorithm_ = Symbol("strategySizeAlgorithm_");
	const strategyHWM_ = Symbol("strategyHWM_");
	const started_ = Symbol("started_");
	const closeRequested_ = Symbol("closeRequested_");
	const pullAgain_ = Symbol("pullAgain_");
	const pulling_ = Symbol("pulling_");
	const cancelSteps_ = Symbol("cancelSteps_");
	const pullSteps_ = Symbol("pullSteps_");
	const autoAllocateChunkSize_ = Symbol("autoAllocateChunkSize_");
	const byobRequest_ = Symbol("byobRequest_");
	const controlledReadableByteStream_ = Symbol("controlledReadableByteStream_");
	const pendingPullIntos_ = Symbol("pendingPullIntos_");
	const closedPromise_ = Symbol("closedPromise_");
	const ownerReadableStream_ = Symbol("ownerReadableStream_");
	const readRequests_ = Symbol("readRequests_");
	const readIntoRequests_ = Symbol("readIntoRequests_");
	const associatedReadableByteStreamController_ = Symbol("associatedReadableByteStreamController_");
	const view_ = Symbol("view_");
	const reader_ = Symbol("reader_");
	const readableStreamController_ = Symbol("readableStreamController_");
	function initializeReadableStream(stream) {
	    stream[state_] = "readable";
	    stream[reader_] = undefined;
	    stream[storedError_] = undefined;
	    stream[readableStreamController_] = undefined;
	}
	function isReadableStream(value) {
	    if (typeof value !== "object" || value === null) {
	        return false;
	    }
	    return readableStreamController_ in value;
	}
	function isReadableStreamLocked(stream) {
	    return stream[reader_] !== undefined;
	}
	function readableStreamGetNumReadIntoRequests(stream) {
	    const reader = stream[reader_];
	    if (reader === undefined) {
	        return 0;
	    }
	    return reader[readIntoRequests_].length;
	}
	function readableStreamGetNumReadRequests(stream) {
	    const reader = stream[reader_];
	    if (reader === undefined) {
	        return 0;
	    }
	    return reader[readRequests_].length;
	}
	function readableStreamCreateReadResult(value, done, forAuthorCode) {
	    const prototype = forAuthorCode ? Object.prototype : null;
	    const result = Object.create(prototype);
	    result.value = value;
	    result.done = done;
	    return result;
	}
	function readableStreamAddReadIntoRequest(stream, forAuthorCode) {
	    const reader = stream[reader_];
	    const conProm = createControlledPromise();
	    conProm.forAuthorCode = forAuthorCode;
	    reader[readIntoRequests_].push(conProm);
	    return conProm.promise;
	}
	function readableStreamAddReadRequest(stream, forAuthorCode) {
	    const reader = stream[reader_];
	    const conProm = createControlledPromise();
	    conProm.forAuthorCode = forAuthorCode;
	    reader[readRequests_].push(conProm);
	    return conProm.promise;
	}
	function readableStreamHasBYOBReader(stream) {
	    const reader = stream[reader_];
	    return isReadableStreamBYOBReader(reader);
	}
	function readableStreamHasDefaultReader(stream) {
	    const reader = stream[reader_];
	    return isReadableStreamDefaultReader(reader);
	}
	function readableStreamCancel(stream, reason) {
	    if (stream[state_] === "closed") {
	        return Promise.resolve(undefined);
	    }
	    if (stream[state_] === "errored") {
	        return Promise.reject(stream[storedError_]);
	    }
	    readableStreamClose(stream);
	    const sourceCancelPromise = stream[readableStreamController_][cancelSteps_](reason);
	    return sourceCancelPromise.then(_ => undefined);
	}
	function readableStreamClose(stream) {
	    stream[state_] = "closed";
	    const reader = stream[reader_];
	    if (reader === undefined) {
	        return;
	    }
	    if (isReadableStreamDefaultReader(reader)) {
	        for (const readRequest of reader[readRequests_]) {
	            readRequest.resolve(readableStreamCreateReadResult(undefined, true, readRequest.forAuthorCode));
	        }
	        reader[readRequests_] = [];
	    }
	    reader[closedPromise_].resolve();
	    reader[closedPromise_].promise.catch(() => { });
	}
	function readableStreamError(stream, error) {
	    if (stream[state_] !== "readable") {
	        throw new RangeError("Stream is in an invalid state");
	    }
	    stream[state_] = "errored";
	    stream[storedError_] = error;
	    const reader = stream[reader_];
	    if (reader === undefined) {
	        return;
	    }
	    if (isReadableStreamDefaultReader(reader)) {
	        for (const readRequest of reader[readRequests_]) {
	            readRequest.reject(error);
	        }
	        reader[readRequests_] = [];
	    }
	    else {
	        const readIntoRequests = reader[readIntoRequests_];
	        for (const readIntoRequest of readIntoRequests) {
	            readIntoRequest.reject(error);
	        }
	        reader[readIntoRequests_] = [];
	    }
	    reader[closedPromise_].reject(error);
	}
	function isReadableStreamDefaultReader(reader) {
	    if (typeof reader !== "object" || reader === null) {
	        return false;
	    }
	    return readRequests_ in reader;
	}
	function isReadableStreamBYOBReader(reader) {
	    if (typeof reader !== "object" || reader === null) {
	        return false;
	    }
	    return readIntoRequests_ in reader;
	}
	function readableStreamReaderGenericInitialize(reader, stream) {
	    reader[ownerReadableStream_] = stream;
	    stream[reader_] = reader;
	    const streamState = stream[state_];
	    reader[closedPromise_] = createControlledPromise();
	    if (streamState === "readable") ;
	    else if (streamState === "closed") {
	        reader[closedPromise_].resolve(undefined);
	    }
	    else {
	        reader[closedPromise_].reject(stream[storedError_]);
	        reader[closedPromise_].promise.catch(() => { });
	    }
	}
	function readableStreamReaderGenericRelease(reader) {
	    const stream = reader[ownerReadableStream_];
	    if (stream === undefined) {
	        throw new TypeError("Reader is in an inconsistent state");
	    }
	    if (stream[state_] === "readable") ;
	    else {
	        reader[closedPromise_] = createControlledPromise();
	    }
	    reader[closedPromise_].reject(new TypeError());
	    reader[closedPromise_].promise.catch(() => { });
	    stream[reader_] = undefined;
	    reader[ownerReadableStream_] = undefined;
	}
	function readableStreamBYOBReaderRead(reader, view, forAuthorCode = false) {
	    const stream = reader[ownerReadableStream_];
	    if (stream[state_] === "errored") {
	        return Promise.reject(stream[storedError_]);
	    }
	    return readableByteStreamControllerPullInto(stream[readableStreamController_], view, forAuthorCode);
	}
	function readableStreamDefaultReaderRead(reader, forAuthorCode = false) {
	    const stream = reader[ownerReadableStream_];
	    if (stream[state_] === "closed") {
	        return Promise.resolve(readableStreamCreateReadResult(undefined, true, forAuthorCode));
	    }
	    if (stream[state_] === "errored") {
	        return Promise.reject(stream[storedError_]);
	    }
	    return stream[readableStreamController_][pullSteps_](forAuthorCode);
	}
	function readableStreamFulfillReadIntoRequest(stream, chunk, done) {
	    const reader = stream[reader_];
	    const readIntoRequest = reader[readIntoRequests_].shift();
	    readIntoRequest.resolve(readableStreamCreateReadResult(chunk, done, readIntoRequest.forAuthorCode));
	}
	function readableStreamFulfillReadRequest(stream, chunk, done) {
	    const reader = stream[reader_];
	    const readRequest = reader[readRequests_].shift();
	    readRequest.resolve(readableStreamCreateReadResult(chunk, done, readRequest.forAuthorCode));
	}
	function setUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
	    controller[controlledReadableStream_] = stream;
	    resetQueue(controller);
	    controller[started_] = false;
	    controller[closeRequested_] = false;
	    controller[pullAgain_] = false;
	    controller[pulling_] = false;
	    controller[strategySizeAlgorithm_] = sizeAlgorithm;
	    controller[strategyHWM_] = highWaterMark;
	    controller[pullAlgorithm_] = pullAlgorithm;
	    controller[cancelAlgorithm_] = cancelAlgorithm;
	    stream[readableStreamController_] = controller;
	    const startResult = startAlgorithm();
	    Promise.resolve(startResult).then(_ => {
	        controller[started_] = true;
	        readableStreamDefaultControllerCallPullIfNeeded(controller);
	    }, error => {
	        readableStreamDefaultControllerError(controller, error);
	    });
	}
	function isReadableStreamDefaultController(value) {
	    if (typeof value !== "object" || value === null) {
	        return false;
	    }
	    return controlledReadableStream_ in value;
	}
	function readableStreamDefaultControllerHasBackpressure(controller) {
	    return !readableStreamDefaultControllerShouldCallPull(controller);
	}
	function readableStreamDefaultControllerCanCloseOrEnqueue(controller) {
	    const state = controller[controlledReadableStream_][state_];
	    return controller[closeRequested_] === false && state === "readable";
	}
	function readableStreamDefaultControllerGetDesiredSize(controller) {
	    const state = controller[controlledReadableStream_][state_];
	    if (state === "errored") {
	        return null;
	    }
	    if (state === "closed") {
	        return 0;
	    }
	    return controller[strategyHWM_] - controller[queueTotalSize_];
	}
	function readableStreamDefaultControllerClose(controller) {
	    controller[closeRequested_] = true;
	    const stream = controller[controlledReadableStream_];
	    if (controller[queue_].length === 0) {
	        readableStreamDefaultControllerClearAlgorithms(controller);
	        readableStreamClose(stream);
	    }
	}
	function readableStreamDefaultControllerEnqueue(controller, chunk) {
	    const stream = controller[controlledReadableStream_];
	    if (isReadableStreamLocked(stream) && readableStreamGetNumReadRequests(stream) > 0) {
	        readableStreamFulfillReadRequest(stream, chunk, false);
	    }
	    else {
	        let chunkSize;
	        try {
	            chunkSize = controller[strategySizeAlgorithm_](chunk);
	        }
	        catch (error) {
	            readableStreamDefaultControllerError(controller, error);
	            throw error;
	        }
	        try {
	            enqueueValueWithSize(controller, chunk, chunkSize);
	        }
	        catch (error) {
	            readableStreamDefaultControllerError(controller, error);
	            throw error;
	        }
	    }
	    readableStreamDefaultControllerCallPullIfNeeded(controller);
	}
	function readableStreamDefaultControllerError(controller, error) {
	    const stream = controller[controlledReadableStream_];
	    if (stream[state_] !== "readable") {
	        return;
	    }
	    resetQueue(controller);
	    readableStreamDefaultControllerClearAlgorithms(controller);
	    readableStreamError(stream, error);
	}
	function readableStreamDefaultControllerCallPullIfNeeded(controller) {
	    if (!readableStreamDefaultControllerShouldCallPull(controller)) {
	        return;
	    }
	    if (controller[pulling_]) {
	        controller[pullAgain_] = true;
	        return;
	    }
	    if (controller[pullAgain_]) {
	        throw new RangeError("Stream controller is in an invalid state.");
	    }
	    controller[pulling_] = true;
	    controller[pullAlgorithm_](controller).then(_ => {
	        controller[pulling_] = false;
	        if (controller[pullAgain_]) {
	            controller[pullAgain_] = false;
	            readableStreamDefaultControllerCallPullIfNeeded(controller);
	        }
	    }, error => {
	        readableStreamDefaultControllerError(controller, error);
	    });
	}
	function readableStreamDefaultControllerShouldCallPull(controller) {
	    const stream = controller[controlledReadableStream_];
	    if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
	        return false;
	    }
	    if (controller[started_] === false) {
	        return false;
	    }
	    if (isReadableStreamLocked(stream) && readableStreamGetNumReadRequests(stream) > 0) {
	        return true;
	    }
	    const desiredSize = readableStreamDefaultControllerGetDesiredSize(controller);
	    if (desiredSize === null) {
	        throw new RangeError("Stream is in an invalid state.");
	    }
	    return desiredSize > 0;
	}
	function readableStreamDefaultControllerClearAlgorithms(controller) {
	    controller[pullAlgorithm_] = undefined;
	    controller[cancelAlgorithm_] = undefined;
	    controller[strategySizeAlgorithm_] = undefined;
	}
	function setUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
	    if (stream[readableStreamController_] !== undefined) {
	        throw new TypeError("Cannot reuse streams");
	    }
	    if (autoAllocateChunkSize !== undefined) {
	        if (!isInteger(autoAllocateChunkSize) || autoAllocateChunkSize <= 0) {
	            throw new RangeError("autoAllocateChunkSize must be a positive, finite integer");
	        }
	    }
	    controller[controlledReadableByteStream_] = stream;
	    controller[pullAgain_] = false;
	    controller[pulling_] = false;
	    readableByteStreamControllerClearPendingPullIntos(controller);
	    resetQueue(controller);
	    controller[closeRequested_] = false;
	    controller[started_] = false;
	    controller[strategyHWM_] = validateAndNormalizeHighWaterMark(highWaterMark);
	    controller[pullAlgorithm_] = pullAlgorithm;
	    controller[cancelAlgorithm_] = cancelAlgorithm;
	    controller[autoAllocateChunkSize_] = autoAllocateChunkSize;
	    controller[pendingPullIntos_] = [];
	    stream[readableStreamController_] = controller;
	    const startResult = startAlgorithm();
	    Promise.resolve(startResult).then(_ => {
	        controller[started_] = true;
	        readableByteStreamControllerCallPullIfNeeded(controller);
	    }, error => {
	        readableByteStreamControllerError(controller, error);
	    });
	}
	function isReadableStreamBYOBRequest(value) {
	    if (typeof value !== "object" || value === null) {
	        return false;
	    }
	    return associatedReadableByteStreamController_ in value;
	}
	function isReadableByteStreamController(value) {
	    if (typeof value !== "object" || value === null) {
	        return false;
	    }
	    return controlledReadableByteStream_ in value;
	}
	function readableByteStreamControllerCallPullIfNeeded(controller) {
	    if (!readableByteStreamControllerShouldCallPull(controller)) {
	        return;
	    }
	    if (controller[pulling_]) {
	        controller[pullAgain_] = true;
	        return;
	    }
	    controller[pulling_] = true;
	    controller[pullAlgorithm_](controller).then(_ => {
	        controller[pulling_] = false;
	        if (controller[pullAgain_]) {
	            controller[pullAgain_] = false;
	            readableByteStreamControllerCallPullIfNeeded(controller);
	        }
	    }, error => {
	        readableByteStreamControllerError(controller, error);
	    });
	}
	function readableByteStreamControllerClearAlgorithms(controller) {
	    controller[pullAlgorithm_] = undefined;
	    controller[cancelAlgorithm_] = undefined;
	}
	function readableByteStreamControllerClearPendingPullIntos(controller) {
	    readableByteStreamControllerInvalidateBYOBRequest(controller);
	    controller[pendingPullIntos_] = [];
	}
	function readableByteStreamControllerClose(controller) {
	    const stream = controller[controlledReadableByteStream_];
	    if (controller[queueTotalSize_] > 0) {
	        controller[closeRequested_] = true;
	        return;
	    }
	    if (controller[pendingPullIntos_].length > 0) {
	        const firstPendingPullInto = controller[pendingPullIntos_][0];
	        if (firstPendingPullInto.bytesFilled > 0) {
	            const error = new TypeError();
	            readableByteStreamControllerError(controller, error);
	            throw error;
	        }
	    }
	    readableByteStreamControllerClearAlgorithms(controller);
	    readableStreamClose(stream);
	}
	function readableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
	    let done = false;
	    if (stream[state_] === "closed") {
	        done = true;
	    }
	    const filledView = readableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
	    if (pullIntoDescriptor.readerType === "default") {
	        readableStreamFulfillReadRequest(stream, filledView, done);
	    }
	    else {
	        readableStreamFulfillReadIntoRequest(stream, filledView, done);
	    }
	}
	function readableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
	    const { bytesFilled, elementSize } = pullIntoDescriptor;
	    return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
	}
	function readableByteStreamControllerEnqueue(controller, chunk) {
	    const stream = controller[controlledReadableByteStream_];
	    const { buffer, byteOffset, byteLength } = chunk;
	    const transferredBuffer = transferArrayBuffer(buffer);
	    if (readableStreamHasDefaultReader(stream)) {
	        if (readableStreamGetNumReadRequests(stream) === 0) {
	            readableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
	        }
	        else {
	            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
	            readableStreamFulfillReadRequest(stream, transferredView, false);
	        }
	    }
	    else if (readableStreamHasBYOBReader(stream)) {
	        readableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
	        readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
	    }
	    else {
	        readableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
	    }
	    readableByteStreamControllerCallPullIfNeeded(controller);
	}
	function readableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
	    controller[queue_].push({ buffer, byteOffset, byteLength });
	    controller[queueTotalSize_] += byteLength;
	}
	function readableByteStreamControllerError(controller, error) {
	    const stream = controller[controlledReadableByteStream_];
	    if (stream[state_] !== "readable") {
	        return;
	    }
	    readableByteStreamControllerClearPendingPullIntos(controller);
	    resetQueue(controller);
	    readableByteStreamControllerClearAlgorithms(controller);
	    readableStreamError(stream, error);
	}
	function readableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
	    readableByteStreamControllerInvalidateBYOBRequest(controller);
	    pullIntoDescriptor.bytesFilled += size;
	}
	function readableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
	    const elementSize = pullIntoDescriptor.elementSize;
	    const currentAlignedBytes = pullIntoDescriptor.bytesFilled - (pullIntoDescriptor.bytesFilled % elementSize);
	    const maxBytesToCopy = Math.min(controller[queueTotalSize_], pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
	    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
	    const maxAlignedBytes = maxBytesFilled - (maxBytesFilled % elementSize);
	    let totalBytesToCopyRemaining = maxBytesToCopy;
	    let ready = false;
	    if (maxAlignedBytes > currentAlignedBytes) {
	        totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
	        ready = true;
	    }
	    const queue = controller[queue_];
	    while (totalBytesToCopyRemaining > 0) {
	        const headOfQueue = queue.front();
	        const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
	        const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
	        copyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
	        if (headOfQueue.byteLength === bytesToCopy) {
	            queue.shift();
	        }
	        else {
	            headOfQueue.byteOffset += bytesToCopy;
	            headOfQueue.byteLength -= bytesToCopy;
	        }
	        controller[queueTotalSize_] -= bytesToCopy;
	        readableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
	        totalBytesToCopyRemaining -= bytesToCopy;
	    }
	    return ready;
	}
	function readableByteStreamControllerGetDesiredSize(controller) {
	    const stream = controller[controlledReadableByteStream_];
	    const state = stream[state_];
	    if (state === "errored") {
	        return null;
	    }
	    if (state === "closed") {
	        return 0;
	    }
	    return controller[strategyHWM_] - controller[queueTotalSize_];
	}
	function readableByteStreamControllerHandleQueueDrain(controller) {
	    if (controller[queueTotalSize_] === 0 && controller[closeRequested_]) {
	        readableByteStreamControllerClearAlgorithms(controller);
	        readableStreamClose(controller[controlledReadableByteStream_]);
	    }
	    else {
	        readableByteStreamControllerCallPullIfNeeded(controller);
	    }
	}
	function readableByteStreamControllerInvalidateBYOBRequest(controller) {
	    const byobRequest = controller[byobRequest_];
	    if (byobRequest === undefined) {
	        return;
	    }
	    byobRequest[associatedReadableByteStreamController_] = undefined;
	    byobRequest[view_] = undefined;
	    controller[byobRequest_] = undefined;
	}
	function readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
	    const pendingPullIntos = controller[pendingPullIntos_];
	    while (pendingPullIntos.length > 0) {
	        if (controller[queueTotalSize_] === 0) {
	            return;
	        }
	        const pullIntoDescriptor = pendingPullIntos[0];
	        if (readableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
	            readableByteStreamControllerShiftPendingPullInto(controller);
	            readableByteStreamControllerCommitPullIntoDescriptor(controller[controlledReadableByteStream_], pullIntoDescriptor);
	        }
	    }
	}
	function readableByteStreamControllerPullInto(controller, view, forAuthorCode) {
	    const stream = controller[controlledReadableByteStream_];
	    const elementSize = view.BYTES_PER_ELEMENT || 1;
	    const ctor = view.constructor;
	    const byteOffset = view.byteOffset;
	    const byteLength = view.byteLength;
	    const buffer = transferArrayBuffer(view.buffer);
	    const pullIntoDescriptor = { buffer, byteOffset, byteLength, bytesFilled: 0, elementSize, ctor, readerType: "byob" };
	    if (controller[pendingPullIntos_].length > 0) {
	        controller[pendingPullIntos_].push(pullIntoDescriptor);
	        return readableStreamAddReadIntoRequest(stream, forAuthorCode);
	    }
	    if (stream[state_] === "closed") {
	        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
	        return Promise.resolve(readableStreamCreateReadResult(emptyView, true, forAuthorCode));
	    }
	    if (controller[queueTotalSize_] > 0) {
	        if (readableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
	            const filledView = readableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
	            readableByteStreamControllerHandleQueueDrain(controller);
	            return Promise.resolve(readableStreamCreateReadResult(filledView, false, forAuthorCode));
	        }
	        if (controller[closeRequested_]) {
	            const error = new TypeError();
	            readableByteStreamControllerError(controller, error);
	            return Promise.reject(error);
	        }
	    }
	    controller[pendingPullIntos_].push(pullIntoDescriptor);
	    const promise = readableStreamAddReadIntoRequest(stream, forAuthorCode);
	    readableByteStreamControllerCallPullIfNeeded(controller);
	    return promise;
	}
	function readableByteStreamControllerRespond(controller, bytesWritten) {
	    bytesWritten = Number(bytesWritten);
	    if (!isFiniteNonNegativeNumber(bytesWritten)) {
	        throw new RangeError("bytesWritten must be a finite, non-negative number");
	    }
	    readableByteStreamControllerRespondInternal(controller, bytesWritten);
	}
	function readableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
	    firstDescriptor.buffer = transferArrayBuffer(firstDescriptor.buffer);
	    const stream = controller[controlledReadableByteStream_];
	    if (readableStreamHasBYOBReader(stream)) {
	        while (readableStreamGetNumReadIntoRequests(stream) > 0) {
	            const pullIntoDescriptor = readableByteStreamControllerShiftPendingPullInto(controller);
	            readableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
	        }
	    }
	}
	function readableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
	    if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {
	        throw new RangeError();
	    }
	    readableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
	    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
	        return;
	    }
	    readableByteStreamControllerShiftPendingPullInto(controller);
	    const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
	    if (remainderSize > 0) {
	        const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
	        const remainder = cloneArrayBuffer(pullIntoDescriptor.buffer, end - remainderSize, remainderSize, ArrayBuffer);
	        readableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
	    }
	    pullIntoDescriptor.buffer = transferArrayBuffer(pullIntoDescriptor.buffer);
	    pullIntoDescriptor.bytesFilled = pullIntoDescriptor.bytesFilled - remainderSize;
	    readableByteStreamControllerCommitPullIntoDescriptor(controller[controlledReadableByteStream_], pullIntoDescriptor);
	    readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
	}
	function readableByteStreamControllerRespondInternal(controller, bytesWritten) {
	    const firstDescriptor = controller[pendingPullIntos_][0];
	    const stream = controller[controlledReadableByteStream_];
	    if (stream[state_] === "closed") {
	        if (bytesWritten !== 0) {
	            throw new TypeError();
	        }
	        readableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
	    }
	    else {
	        readableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
	    }
	    readableByteStreamControllerCallPullIfNeeded(controller);
	}
	function readableByteStreamControllerRespondWithNewView(controller, view) {
	    const firstDescriptor = controller[pendingPullIntos_][0];
	    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
	        throw new RangeError();
	    }
	    if (firstDescriptor.byteLength !== view.byteLength) {
	        throw new RangeError();
	    }
	    firstDescriptor.buffer = view.buffer;
	    readableByteStreamControllerRespondInternal(controller, view.byteLength);
	}
	function readableByteStreamControllerShiftPendingPullInto(controller) {
	    const descriptor = controller[pendingPullIntos_].shift();
	    readableByteStreamControllerInvalidateBYOBRequest(controller);
	    return descriptor;
	}
	function readableByteStreamControllerShouldCallPull(controller) {
	    const stream = controller[controlledReadableByteStream_];
	    if (stream[state_] !== "readable") {
	        return false;
	    }
	    if (controller[closeRequested_]) {
	        return false;
	    }
	    if (!controller[started_]) {
	        return false;
	    }
	    if (readableStreamHasDefaultReader(stream) && readableStreamGetNumReadRequests(stream) > 0) {
	        return true;
	    }
	    if (readableStreamHasBYOBReader(stream) && readableStreamGetNumReadIntoRequests(stream) > 0) {
	        return true;
	    }
	    const desiredSize = readableByteStreamControllerGetDesiredSize(controller);
	    return desiredSize > 0;
	}
	function setUpReadableStreamBYOBRequest(request, controller, view) {
	    if (!isReadableByteStreamController(controller)) {
	        throw new TypeError();
	    }
	    if (!ArrayBuffer.isView(view)) {
	        throw new TypeError();
	    }
	    request[associatedReadableByteStreamController_] = controller;
	    request[view_] = view;
	}

	const backpressure_ = Symbol("backpressure_");
	const closeRequest_ = Symbol("closeRequest_");
	const inFlightWriteRequest_ = Symbol("inFlightWriteRequest_");
	const inFlightCloseRequest_ = Symbol("inFlightCloseRequest_");
	const pendingAbortRequest_ = Symbol("pendingAbortRequest_");
	const writableStreamController_ = Symbol("writableStreamController_");
	const writer_ = Symbol("writer_");
	const writeRequests_ = Symbol("writeRequests_");
	const abortAlgorithm_ = Symbol("abortAlgorithm_");
	const closeAlgorithm_ = Symbol("closeAlgorithm_");
	const controlledWritableStream_ = Symbol("controlledWritableStream_");
	const started_$1 = Symbol("started_");
	const strategyHWM_$1 = Symbol("strategyHWM_");
	const strategySizeAlgorithm_$1 = Symbol("strategySizeAlgorithm_");
	const writeAlgorithm_ = Symbol("writeAlgorithm_");
	const ownerWritableStream_ = Symbol("ownerWritableStream_");
	const closedPromise_$1 = Symbol("closedPromise_");
	const readyPromise_ = Symbol("readyPromise_");
	const errorSteps_ = Symbol("errorSteps_");
	const abortSteps_ = Symbol("abortSteps_");
	function initializeWritableStream(stream) {
	    stream[state_] = "writable";
	    stream[storedError_] = undefined;
	    stream[writer_] = undefined;
	    stream[writableStreamController_] = undefined;
	    stream[inFlightWriteRequest_] = undefined;
	    stream[closeRequest_] = undefined;
	    stream[inFlightCloseRequest_] = undefined;
	    stream[pendingAbortRequest_] = undefined;
	    stream[writeRequests_] = [];
	    stream[backpressure_] = false;
	}
	function isWritableStream(value) {
	    if (typeof value !== "object" || value === null) {
	        return false;
	    }
	    return writableStreamController_ in value;
	}
	function isWritableStreamLocked(stream) {
	    return stream[writer_] !== undefined;
	}
	function writableStreamAbort(stream, reason) {
	    const state = stream[state_];
	    if (state === "closed" || state === "errored") {
	        return Promise.resolve(undefined);
	    }
	    let pending = stream[pendingAbortRequest_];
	    if (pending !== undefined) {
	        return pending.promise;
	    }
	    let wasAlreadyErroring = false;
	    if (state === "erroring") {
	        wasAlreadyErroring = true;
	        reason = undefined;
	    }
	    pending = {
	        reason,
	        wasAlreadyErroring
	    };
	    const promise = new Promise((resolve, reject) => {
	        pending.resolve = resolve;
	        pending.reject = reject;
	    });
	    pending.promise = promise;
	    stream[pendingAbortRequest_] = pending;
	    if (!wasAlreadyErroring) {
	        writableStreamStartErroring(stream, reason);
	    }
	    return promise;
	}
	function writableStreamAddWriteRequest(stream) {
	    const writePromise = createControlledPromise();
	    stream[writeRequests_].push(writePromise);
	    return writePromise.promise;
	}
	function writableStreamDealWithRejection(stream, error) {
	    const state = stream[state_];
	    if (state === "writable") {
	        writableStreamStartErroring(stream, error);
	        return;
	    }
	    writableStreamFinishErroring(stream);
	}
	function writableStreamStartErroring(stream, reason) {
	    const controller = stream[writableStreamController_];
	    stream[state_] = "erroring";
	    stream[storedError_] = reason;
	    const writer = stream[writer_];
	    if (writer !== undefined) {
	        writableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
	    }
	    if (!writableStreamHasOperationMarkedInFlight(stream) && controller[started_$1]) {
	        writableStreamFinishErroring(stream);
	    }
	}
	function writableStreamFinishErroring(stream) {
	    stream[state_] = "errored";
	    const controller = stream[writableStreamController_];
	    controller[errorSteps_]();
	    const storedError = stream[storedError_];
	    for (const writeRequest of stream[writeRequests_]) {
	        writeRequest.reject(storedError);
	    }
	    stream[writeRequests_] = [];
	    const abortRequest = stream[pendingAbortRequest_];
	    if (abortRequest === undefined) {
	        writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
	        return;
	    }
	    stream[pendingAbortRequest_] = undefined;
	    if (abortRequest.wasAlreadyErroring) {
	        abortRequest.reject(storedError);
	        writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
	        return;
	    }
	    const promise = controller[abortSteps_](abortRequest.reason);
	    promise.then(_ => {
	        abortRequest.resolve();
	        writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
	    }, error => {
	        abortRequest.reject(error);
	        writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
	    });
	}
	function writableStreamFinishInFlightWrite(stream) {
	    stream[inFlightWriteRequest_].resolve(undefined);
	    stream[inFlightWriteRequest_] = undefined;
	}
	function writableStreamFinishInFlightWriteWithError(stream, error) {
	    stream[inFlightWriteRequest_].reject(error);
	    stream[inFlightWriteRequest_] = undefined;
	    writableStreamDealWithRejection(stream, error);
	}
	function writableStreamFinishInFlightClose(stream) {
	    stream[inFlightCloseRequest_].resolve(undefined);
	    stream[inFlightCloseRequest_] = undefined;
	    const state = stream[state_];
	    if (state === "erroring") {
	        stream[storedError_] = undefined;
	        if (stream[pendingAbortRequest_] !== undefined) {
	            stream[pendingAbortRequest_].resolve();
	            stream[pendingAbortRequest_] = undefined;
	        }
	    }
	    stream[state_] = "closed";
	    const writer = stream[writer_];
	    if (writer !== undefined) {
	        writer[closedPromise_$1].resolve(undefined);
	    }
	}
	function writableStreamFinishInFlightCloseWithError(stream, error) {
	    stream[inFlightCloseRequest_].reject(error);
	    stream[inFlightCloseRequest_] = undefined;
	    if (stream[pendingAbortRequest_] !== undefined) {
	        stream[pendingAbortRequest_].reject(error);
	        stream[pendingAbortRequest_] = undefined;
	    }
	    writableStreamDealWithRejection(stream, error);
	}
	function writableStreamCloseQueuedOrInFlight(stream) {
	    return (stream[closeRequest_] !== undefined || stream[inFlightCloseRequest_] !== undefined);
	}
	function writableStreamHasOperationMarkedInFlight(stream) {
	    return stream[inFlightWriteRequest_] !== undefined || stream[inFlightCloseRequest_] !== undefined;
	}
	function writableStreamMarkCloseRequestInFlight(stream) {
	    stream[inFlightCloseRequest_] = stream[closeRequest_];
	    stream[closeRequest_] = undefined;
	}
	function writableStreamMarkFirstWriteRequestInFlight(stream) {
	    const writeRequest = stream[writeRequests_].shift();
	    stream[inFlightWriteRequest_] = writeRequest;
	}
	function writableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
	    const closeRequest = stream[closeRequest_];
	    if (closeRequest !== undefined) {
	        closeRequest.reject(stream[storedError_]);
	        stream[closeRequest_] = undefined;
	    }
	    const writer = stream[writer_];
	    if (writer !== undefined) {
	        writer[closedPromise_$1].reject(stream[storedError_]);
	        writer[closedPromise_$1].promise.catch(() => { });
	    }
	}
	function writableStreamUpdateBackpressure(stream, backpressure) {
	    const writer = stream[writer_];
	    if (writer !== undefined && backpressure !== stream[backpressure_]) {
	        if (backpressure) {
	            writer[readyPromise_] = createControlledPromise();
	        }
	        else {
	            writer[readyPromise_].resolve(undefined);
	        }
	    }
	    stream[backpressure_] = backpressure;
	}
	function isWritableStreamDefaultWriter(value) {
	    if (typeof value !== "object" || value === null) {
	        return false;
	    }
	    return ownerWritableStream_ in value;
	}
	function writableStreamDefaultWriterAbort(writer, reason) {
	    const stream = writer[ownerWritableStream_];
	    return writableStreamAbort(stream, reason);
	}
	function writableStreamDefaultWriterClose(writer) {
	    const stream = writer[ownerWritableStream_];
	    const state = stream[state_];
	    if (state === "closed" || state === "errored") {
	        return Promise.reject(new TypeError("Writer stream is already closed or errored"));
	    }
	    const closePromise = createControlledPromise();
	    stream[closeRequest_] = closePromise;
	    if (stream[backpressure_] && state === "writable") {
	        writer[readyPromise_].resolve(undefined);
	    }
	    writableStreamDefaultControllerClose(stream[writableStreamController_]);
	    return closePromise.promise;
	}
	function writableStreamDefaultWriterCloseWithErrorPropagation(writer) {
	    const stream = writer[ownerWritableStream_];
	    const state = stream[state_];
	    if (writableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
	        return Promise.resolve(undefined);
	    }
	    if (state === "errored") {
	        return Promise.reject(stream[storedError_]);
	    }
	    return writableStreamDefaultWriterClose(writer);
	}
	function writableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
	    const closedPromise = writer[closedPromise_$1];
	    if (closedPromise.state === ControlledPromiseState.Pending) {
	        closedPromise.reject(error);
	    }
	    else {
	        writer[closedPromise_$1] = createControlledPromise();
	        writer[closedPromise_$1].reject(error);
	    }
	    writer[closedPromise_$1].promise.catch(() => { });
	}
	function writableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
	    const readyPromise = writer[readyPromise_];
	    if (readyPromise.state === ControlledPromiseState.Pending) {
	        readyPromise.reject(error);
	    }
	    else {
	        writer[readyPromise_] = createControlledPromise();
	        writer[readyPromise_].reject(error);
	    }
	    writer[readyPromise_].promise.catch(() => { });
	}
	function writableStreamDefaultWriterGetDesiredSize(writer) {
	    const stream = writer[ownerWritableStream_];
	    const state = stream[state_];
	    if (state === "errored" || state === "erroring") {
	        return null;
	    }
	    if (state === "closed") {
	        return 0;
	    }
	    return writableStreamDefaultControllerGetDesiredSize(stream[writableStreamController_]);
	}
	function writableStreamDefaultWriterRelease(writer) {
	    const stream = writer[ownerWritableStream_];
	    const releasedError = new TypeError();
	    writableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
	    writableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
	    stream[writer_] = undefined;
	    writer[ownerWritableStream_] = undefined;
	}
	function writableStreamDefaultWriterWrite(writer, chunk) {
	    const stream = writer[ownerWritableStream_];
	    const controller = stream[writableStreamController_];
	    const chunkSize = writableStreamDefaultControllerGetChunkSize(controller, chunk);
	    if (writer[ownerWritableStream_] !== stream) {
	        return Promise.reject(new TypeError());
	    }
	    const state = stream[state_];
	    if (state === "errored") {
	        return Promise.reject(stream[storedError_]);
	    }
	    if (writableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
	        return Promise.reject(new TypeError("Cannot write to a closing or closed stream"));
	    }
	    if (state === "erroring") {
	        return Promise.reject(stream[storedError_]);
	    }
	    const promise = writableStreamAddWriteRequest(stream);
	    writableStreamDefaultControllerWrite(controller, chunk, chunkSize);
	    return promise;
	}
	function setUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
	    if (!isWritableStream(stream)) {
	        throw new TypeError();
	    }
	    if (stream[writableStreamController_] !== undefined) {
	        throw new TypeError();
	    }
	    controller[controlledWritableStream_] = stream;
	    stream[writableStreamController_] = controller;
	    resetQueue(controller);
	    controller[started_$1] = false;
	    controller[strategySizeAlgorithm_$1] = sizeAlgorithm;
	    controller[strategyHWM_$1] = highWaterMark;
	    controller[writeAlgorithm_] = writeAlgorithm;
	    controller[closeAlgorithm_] = closeAlgorithm;
	    controller[abortAlgorithm_] = abortAlgorithm;
	    const backpressure = writableStreamDefaultControllerGetBackpressure(controller);
	    writableStreamUpdateBackpressure(stream, backpressure);
	    const startResult = startAlgorithm();
	    Promise.resolve(startResult).then(_ => {
	        controller[started_$1] = true;
	        writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
	    }, error => {
	        controller[started_$1] = true;
	        writableStreamDealWithRejection(stream, error);
	    });
	}
	function isWritableStreamDefaultController(value) {
	    if (typeof value !== "object" || value === null) {
	        return false;
	    }
	    return controlledWritableStream_ in value;
	}
	function writableStreamDefaultControllerClearAlgorithms(controller) {
	    controller[writeAlgorithm_] = undefined;
	    controller[closeAlgorithm_] = undefined;
	    controller[abortAlgorithm_] = undefined;
	    controller[strategySizeAlgorithm_$1] = undefined;
	}
	function writableStreamDefaultControllerClose(controller) {
	    enqueueValueWithSize(controller, "close", 0);
	    writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
	}
	function writableStreamDefaultControllerGetChunkSize(controller, chunk) {
	    let chunkSize;
	    try {
	        chunkSize = controller[strategySizeAlgorithm_$1](chunk);
	    }
	    catch (error) {
	        writableStreamDefaultControllerErrorIfNeeded(controller, error);
	        chunkSize = 1;
	    }
	    return chunkSize;
	}
	function writableStreamDefaultControllerGetDesiredSize(controller) {
	    return controller[strategyHWM_$1] - controller[queueTotalSize_];
	}
	function writableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
	    try {
	        enqueueValueWithSize(controller, { chunk }, chunkSize);
	    }
	    catch (error) {
	        writableStreamDefaultControllerErrorIfNeeded(controller, error);
	        return;
	    }
	    const stream = controller[controlledWritableStream_];
	    if (!writableStreamCloseQueuedOrInFlight(stream) && stream[state_] === "writable") {
	        const backpressure = writableStreamDefaultControllerGetBackpressure(controller);
	        writableStreamUpdateBackpressure(stream, backpressure);
	    }
	    writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
	}
	function writableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
	    if (!controller[started_$1]) {
	        return;
	    }
	    const stream = controller[controlledWritableStream_];
	    if (stream[inFlightWriteRequest_] !== undefined) {
	        return;
	    }
	    const state = stream[state_];
	    if (state === "closed" || state === "errored") {
	        return;
	    }
	    if (state === "erroring") {
	        writableStreamFinishErroring(stream);
	        return;
	    }
	    if (controller[queue_].length === 0) {
	        return;
	    }
	    const writeRecord = peekQueueValue(controller);
	    if (writeRecord === "close") {
	        writableStreamDefaultControllerProcessClose(controller);
	    }
	    else {
	        writableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);
	    }
	}
	function writableStreamDefaultControllerErrorIfNeeded(controller, error) {
	    if (controller[controlledWritableStream_][state_] === "writable") {
	        writableStreamDefaultControllerError(controller, error);
	    }
	}
	function writableStreamDefaultControllerProcessClose(controller) {
	    const stream = controller[controlledWritableStream_];
	    writableStreamMarkCloseRequestInFlight(stream);
	    dequeueValue(controller);
	    const sinkClosePromise = controller[closeAlgorithm_]();
	    writableStreamDefaultControllerClearAlgorithms(controller);
	    sinkClosePromise.then(_ => {
	        writableStreamFinishInFlightClose(stream);
	    }, error => {
	        writableStreamFinishInFlightCloseWithError(stream, error);
	    });
	}
	function writableStreamDefaultControllerProcessWrite(controller, chunk) {
	    const stream = controller[controlledWritableStream_];
	    writableStreamMarkFirstWriteRequestInFlight(stream);
	    controller[writeAlgorithm_](chunk).then(_ => {
	        writableStreamFinishInFlightWrite(stream);
	        const state = stream[state_];
	        dequeueValue(controller);
	        if (!writableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
	            const backpressure = writableStreamDefaultControllerGetBackpressure(controller);
	            writableStreamUpdateBackpressure(stream, backpressure);
	        }
	        writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
	    }, error => {
	        if (stream[state_] === "writable") {
	            writableStreamDefaultControllerClearAlgorithms(controller);
	        }
	        writableStreamFinishInFlightWriteWithError(stream, error);
	    });
	}
	function writableStreamDefaultControllerGetBackpressure(controller) {
	    const desiredSize = writableStreamDefaultControllerGetDesiredSize(controller);
	    return desiredSize <= 0;
	}
	function writableStreamDefaultControllerError(controller, error) {
	    const stream = controller[controlledWritableStream_];
	    writableStreamDefaultControllerClearAlgorithms(controller);
	    writableStreamStartErroring(stream, error);
	}

	class ReadableStreamDefaultReader {
	    constructor(stream) {
	        if (!isReadableStream(stream)) {
	            throw new TypeError();
	        }
	        if (isReadableStreamLocked(stream)) {
	            throw new TypeError("The stream is locked.");
	        }
	        readableStreamReaderGenericInitialize(this, stream);
	        this[readRequests_] = [];
	    }
	    get closed() {
	        if (!isReadableStreamDefaultReader(this)) {
	            return Promise.reject(new TypeError());
	        }
	        return this[closedPromise_].promise;
	    }
	    cancel(reason) {
	        if (!isReadableStreamDefaultReader(this)) {
	            return Promise.reject(new TypeError());
	        }
	        const stream = this[ownerReadableStream_];
	        if (stream === undefined) {
	            return Promise.reject(new TypeError("Reader is not associated with a stream"));
	        }
	        return readableStreamCancel(stream, reason);
	    }
	    read() {
	        if (!isReadableStreamDefaultReader(this)) {
	            return Promise.reject(new TypeError());
	        }
	        if (this[ownerReadableStream_] === undefined) {
	            return Promise.reject(new TypeError("Reader is not associated with a stream"));
	        }
	        return readableStreamDefaultReaderRead(this, true);
	    }
	    releaseLock() {
	        if (!isReadableStreamDefaultReader(this)) {
	            throw new TypeError();
	        }
	        if (this[ownerReadableStream_] === undefined) {
	            return;
	        }
	        if (this[readRequests_].length !== 0) {
	            throw new TypeError("Cannot release a stream with pending read requests");
	        }
	        readableStreamReaderGenericRelease(this);
	    }
	}

	class WritableStreamDefaultWriter {
	    constructor(stream) {
	        if (!isWritableStream(stream)) {
	            throw new TypeError();
	        }
	        if (isWritableStreamLocked(stream)) {
	            throw new TypeError("Stream is already locked");
	        }
	        this[ownerWritableStream_] = stream;
	        stream[writer_] = this;
	        const readyPromise = createControlledPromise();
	        const closedPromise = createControlledPromise();
	        this[readyPromise_] = readyPromise;
	        this[closedPromise_$1] = closedPromise;
	        const state = stream[state_];
	        if (state === "writable") {
	            if (!writableStreamCloseQueuedOrInFlight(stream) && stream[backpressure_]) ;
	            else {
	                readyPromise.resolve(undefined);
	            }
	        }
	        else if (state === "erroring") {
	            readyPromise.reject(stream[storedError_]);
	            readyPromise.promise.catch(() => { });
	        }
	        else if (state === "closed") {
	            readyPromise.resolve(undefined);
	            closedPromise.resolve(undefined);
	        }
	        else {
	            const storedError = stream[storedError_];
	            readyPromise.reject(storedError);
	            readyPromise.promise.catch(() => { });
	            closedPromise.reject(storedError);
	            closedPromise.promise.catch(() => { });
	        }
	    }
	    abort(reason) {
	        if (!isWritableStreamDefaultWriter(this)) {
	            return Promise.reject(new TypeError());
	        }
	        if (this[ownerWritableStream_] === undefined) {
	            return Promise.reject(new TypeError("Writer is not connected to a stream"));
	        }
	        return writableStreamDefaultWriterAbort(this, reason);
	    }
	    close() {
	        if (!isWritableStreamDefaultWriter(this)) {
	            return Promise.reject(new TypeError());
	        }
	        const stream = this[ownerWritableStream_];
	        if (stream === undefined) {
	            return Promise.reject(new TypeError("Writer is not connected to a stream"));
	        }
	        if (writableStreamCloseQueuedOrInFlight(stream)) {
	            return Promise.reject(new TypeError());
	        }
	        return writableStreamDefaultWriterClose(this);
	    }
	    releaseLock() {
	        const stream = this[ownerWritableStream_];
	        if (stream === undefined) {
	            return;
	        }
	        writableStreamDefaultWriterRelease(this);
	    }
	    write(chunk) {
	        if (!isWritableStreamDefaultWriter(this)) {
	            return Promise.reject(new TypeError());
	        }
	        if (this[ownerWritableStream_] === undefined) {
	            return Promise.reject(new TypeError("Writer is not connected to a stream"));
	        }
	        return writableStreamDefaultWriterWrite(this, chunk);
	    }
	    get closed() {
	        if (!isWritableStreamDefaultWriter(this)) {
	            return Promise.reject(new TypeError());
	        }
	        return this[closedPromise_$1].promise;
	    }
	    get desiredSize() {
	        if (!isWritableStreamDefaultWriter(this)) {
	            throw new TypeError();
	        }
	        if (this[ownerWritableStream_] === undefined) {
	            throw new TypeError("Writer is not connected to stream");
	        }
	        return writableStreamDefaultWriterGetDesiredSize(this);
	    }
	    get ready() {
	        if (!isWritableStreamDefaultWriter(this)) {
	            return Promise.reject(new TypeError());
	        }
	        return this[readyPromise_].promise;
	    }
	}

	function pipeTo(source, dest, options) {
	    const preventClose = !!options.preventClose;
	    const preventAbort = !!options.preventAbort;
	    const preventCancel = !!options.preventCancel;
	    const signal = options.signal;
	    let shuttingDown = false;
	    let latestWrite = Promise.resolve();
	    const promise = createControlledPromise();
	    const reader = new ReadableStreamDefaultReader(source);
	    const writer = new WritableStreamDefaultWriter(dest);
	    let abortAlgorithm;
	    if (signal !== undefined) {
	        abortAlgorithm = () => {
	            const error = new DOMException("Aborted", "AbortError");
	            const actions = [];
	            if (preventAbort === false) {
	                actions.push(() => {
	                    if (dest[state_] === "writable") {
	                        return writableStreamAbort(dest, error);
	                    }
	                    return Promise.resolve();
	                });
	            }
	            if (preventCancel === false) {
	                actions.push(() => {
	                    if (source[state_] === "readable") {
	                        return readableStreamCancel(source, error);
	                    }
	                    return Promise.resolve();
	                });
	            }
	            shutDown(() => {
	                return Promise.all(actions.map(a => a())).then(_ => undefined);
	            }, { actualError: error });
	        };
	        if (signal.aborted === true) {
	            abortAlgorithm();
	        }
	        else {
	            signal.addEventListener("abort", abortAlgorithm);
	        }
	    }
	    function onStreamErrored(stream, promise, action) {
	        if (stream[state_] === "errored") {
	            action(stream[storedError_]);
	        }
	        else {
	            promise.catch(action);
	        }
	    }
	    function onStreamClosed(stream, promise, action) {
	        if (stream[state_] === "closed") {
	            action();
	        }
	        else {
	            promise.then(action);
	        }
	    }
	    onStreamErrored(source, reader[closedPromise_].promise, error => {
	        if (!preventAbort) {
	            shutDown(() => writableStreamAbort(dest, error), { actualError: error });
	        }
	        else {
	            shutDown(undefined, { actualError: error });
	        }
	    });
	    onStreamErrored(dest, writer[closedPromise_$1].promise, error => {
	        if (!preventCancel) {
	            shutDown(() => readableStreamCancel(source, error), { actualError: error });
	        }
	        else {
	            shutDown(undefined, { actualError: error });
	        }
	    });
	    onStreamClosed(source, reader[closedPromise_].promise, () => {
	        if (!preventClose) {
	            shutDown(() => writableStreamDefaultWriterCloseWithErrorPropagation(writer));
	        }
	        else {
	            shutDown();
	        }
	    });
	    if (writableStreamCloseQueuedOrInFlight(dest) || dest[state_] === "closed") {
	        const destClosed = new TypeError();
	        if (!preventCancel) {
	            shutDown(() => readableStreamCancel(source, destClosed), { actualError: destClosed });
	        }
	        else {
	            shutDown(undefined, { actualError: destClosed });
	        }
	    }
	    function awaitLatestWrite() {
	        const curLatestWrite = latestWrite;
	        return latestWrite.then(() => curLatestWrite === latestWrite ? undefined : awaitLatestWrite());
	    }
	    function flushRemainder() {
	        if (dest[state_] === "writable" && (!writableStreamCloseQueuedOrInFlight(dest))) {
	            return awaitLatestWrite();
	        }
	        else {
	            return undefined;
	        }
	    }
	    function shutDown(action, error) {
	        if (shuttingDown) {
	            return;
	        }
	        shuttingDown = true;
	        if (action === undefined) {
	            action = () => Promise.resolve();
	        }
	        function finishShutDown() {
	            action().then(_ => finalize(error), newError => finalize({ actualError: newError }));
	        }
	        const flushWait = flushRemainder();
	        if (flushWait) {
	            flushWait.then(finishShutDown);
	        }
	        else {
	            finishShutDown();
	        }
	    }
	    function finalize(error) {
	        writableStreamDefaultWriterRelease(writer);
	        readableStreamReaderGenericRelease(reader);
	        if (signal && abortAlgorithm) {
	            signal.removeEventListener("abort", abortAlgorithm);
	        }
	        if (error) {
	            promise.reject(error.actualError);
	        }
	        else {
	            promise.resolve(undefined);
	        }
	    }
	    function next() {
	        if (shuttingDown) {
	            return;
	        }
	        writer[readyPromise_].promise.then(() => {
	            readableStreamDefaultReaderRead(reader).then(({ value, done }) => {
	                if (done) {
	                    return;
	                }
	                latestWrite = writableStreamDefaultWriterWrite(writer, value).catch(() => { });
	                next();
	            }, _error => {
	                latestWrite = Promise.resolve();
	            });
	        });
	    }
	    if (!shuttingDown) {
	        next();
	    }
	    return promise.promise;
	}

	class ReadableStreamDefaultController {
	    constructor() {
	        throw new TypeError();
	    }
	    get desiredSize() {
	        return readableStreamDefaultControllerGetDesiredSize(this);
	    }
	    close() {
	        if (!isReadableStreamDefaultController(this)) {
	            throw new TypeError();
	        }
	        if (!readableStreamDefaultControllerCanCloseOrEnqueue(this)) {
	            throw new TypeError("Cannot close, the stream is already closing or not readable");
	        }
	        readableStreamDefaultControllerClose(this);
	    }
	    enqueue(chunk) {
	        if (!isReadableStreamDefaultController(this)) {
	            throw new TypeError();
	        }
	        if (!readableStreamDefaultControllerCanCloseOrEnqueue(this)) {
	            throw new TypeError("Cannot enqueue, the stream is closing or not readable");
	        }
	        readableStreamDefaultControllerEnqueue(this, chunk);
	    }
	    error(e) {
	        if (!isReadableStreamDefaultController(this)) {
	            throw new TypeError();
	        }
	        readableStreamDefaultControllerError(this, e);
	    }
	    [(cancelSteps_)](reason) {
	        resetQueue(this);
	        const result = this[cancelAlgorithm_](reason);
	        readableStreamDefaultControllerClearAlgorithms(this);
	        return result;
	    }
	    [pullSteps_](forAuthorCode) {
	        const stream = this[controlledReadableStream_];
	        if (this[queue_].length > 0) {
	            const chunk = dequeueValue(this);
	            if (this[closeRequested_] && this[queue_].length === 0) {
	                readableStreamDefaultControllerClearAlgorithms(this);
	                readableStreamClose(stream);
	            }
	            else {
	                readableStreamDefaultControllerCallPullIfNeeded(this);
	            }
	            return Promise.resolve(readableStreamCreateReadResult(chunk, false, forAuthorCode));
	        }
	        const pendingPromise = readableStreamAddReadRequest(stream, forAuthorCode);
	        readableStreamDefaultControllerCallPullIfNeeded(this);
	        return pendingPromise;
	    }
	}
	function setUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
	    const controller = Object.create(ReadableStreamDefaultController.prototype);
	    const startAlgorithm = () => {
	        return invokeOrNoop(underlyingSource, "start", [controller]);
	    };
	    const pullAlgorithm = createAlgorithmFromUnderlyingMethod(underlyingSource, "pull", [controller]);
	    const cancelAlgorithm = createAlgorithmFromUnderlyingMethod(underlyingSource, "cancel", []);
	    setUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
	}

	class ReadableStreamBYOBRequest {
	    constructor() {
	        throw new TypeError();
	    }
	    get view() {
	        if (!isReadableStreamBYOBRequest(this)) {
	            throw new TypeError();
	        }
	        return this[view_];
	    }
	    respond(bytesWritten) {
	        if (!isReadableStreamBYOBRequest(this)) {
	            throw new TypeError();
	        }
	        if (this[associatedReadableByteStreamController_] === undefined) {
	            throw new TypeError();
	        }
	        return readableByteStreamControllerRespond(this[associatedReadableByteStreamController_], bytesWritten);
	    }
	    respondWithNewView(view) {
	        if (!isReadableStreamBYOBRequest(this)) {
	            throw new TypeError();
	        }
	        if (this[associatedReadableByteStreamController_] === undefined) {
	            throw new TypeError();
	        }
	        if (!ArrayBuffer.isView(view)) {
	            throw new TypeError("view parameter must be a TypedArray");
	        }
	        return readableByteStreamControllerRespondWithNewView(this[associatedReadableByteStreamController_], view);
	    }
	}

	class ReadableByteStreamController {
	    constructor() {
	        throw new TypeError();
	    }
	    get byobRequest() {
	        if (!isReadableByteStreamController(this)) {
	            throw new TypeError();
	        }
	        if (this[byobRequest_] === undefined && this[pendingPullIntos_].length > 0) {
	            const firstDescriptor = this[pendingPullIntos_][0];
	            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
	            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
	            setUpReadableStreamBYOBRequest(byobRequest, this, view);
	            this[byobRequest_] = byobRequest;
	        }
	        return this[byobRequest_];
	    }
	    get desiredSize() {
	        if (!isReadableByteStreamController(this)) {
	            throw new TypeError();
	        }
	        return readableByteStreamControllerGetDesiredSize(this);
	    }
	    close() {
	        if (!isReadableByteStreamController(this)) {
	            throw new TypeError();
	        }
	        if (this[closeRequested_]) {
	            throw new TypeError("Stream is already closing");
	        }
	        if (this[controlledReadableByteStream_][state_] !== "readable") {
	            throw new TypeError("Stream is closed or errored");
	        }
	        readableByteStreamControllerClose(this);
	    }
	    enqueue(chunk) {
	        if (!isReadableByteStreamController(this)) {
	            throw new TypeError();
	        }
	        if (this[closeRequested_]) {
	            throw new TypeError("Stream is already closing");
	        }
	        if (this[controlledReadableByteStream_][state_] !== "readable") {
	            throw new TypeError("Stream is closed or errored");
	        }
	        if (!ArrayBuffer.isView(chunk)) {
	            throw new TypeError("chunk must be a valid ArrayBufferView");
	        }
	        return readableByteStreamControllerEnqueue(this, chunk);
	    }
	    error(error) {
	        if (!isReadableByteStreamController(this)) {
	            throw new TypeError();
	        }
	        readableByteStreamControllerError(this, error);
	    }
	    [(cancelSteps_)](reason) {
	        if (this[pendingPullIntos_].length > 0) {
	            const firstDescriptor = this[pendingPullIntos_][0];
	            firstDescriptor.bytesFilled = 0;
	        }
	        resetQueue(this);
	        const result = this[cancelAlgorithm_](reason);
	        readableByteStreamControllerClearAlgorithms(this);
	        return result;
	    }
	    [pullSteps_](forAuthorCode) {
	        const stream = this[controlledReadableByteStream_];
	        if (this[queueTotalSize_] > 0) {
	            const entry = this[queue_].shift();
	            this[queueTotalSize_] -= entry.byteLength;
	            readableByteStreamControllerHandleQueueDrain(this);
	            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
	            return Promise.resolve(readableStreamCreateReadResult(view, false, forAuthorCode));
	        }
	        const autoAllocateChunkSize = this[autoAllocateChunkSize_];
	        if (autoAllocateChunkSize !== undefined) {
	            let buffer;
	            try {
	                buffer = new ArrayBuffer(autoAllocateChunkSize);
	            }
	            catch (error) {
	                return Promise.reject(error);
	            }
	            const pullIntoDescriptor = {
	                buffer,
	                byteOffset: 0,
	                byteLength: autoAllocateChunkSize,
	                bytesFilled: 0,
	                elementSize: 1,
	                ctor: Uint8Array,
	                readerType: "default"
	            };
	            this[pendingPullIntos_].push(pullIntoDescriptor);
	        }
	        const promise = readableStreamAddReadRequest(stream, forAuthorCode);
	        readableByteStreamControllerCallPullIfNeeded(this);
	        return promise;
	    }
	}
	function setUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
	    const controller = Object.create(ReadableByteStreamController.prototype);
	    const startAlgorithm = () => {
	        return invokeOrNoop(underlyingByteSource, "start", [controller]);
	    };
	    const pullAlgorithm = createAlgorithmFromUnderlyingMethod(underlyingByteSource, "pull", [controller]);
	    const cancelAlgorithm = createAlgorithmFromUnderlyingMethod(underlyingByteSource, "cancel", []);
	    let autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
	    if (autoAllocateChunkSize !== undefined) {
	        autoAllocateChunkSize = Number(autoAllocateChunkSize);
	        if (!isInteger(autoAllocateChunkSize) || autoAllocateChunkSize <= 0) {
	            throw new RangeError("autoAllocateChunkSize must be a positive, finite integer");
	        }
	    }
	    setUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
	}

	class SDReadableStreamBYOBReader {
	    constructor(stream) {
	        if (!isReadableStream(stream)) {
	            throw new TypeError();
	        }
	        if (!isReadableByteStreamController(stream[readableStreamController_])) {
	            throw new TypeError();
	        }
	        if (isReadableStreamLocked(stream)) {
	            throw new TypeError("The stream is locked.");
	        }
	        readableStreamReaderGenericInitialize(this, stream);
	        this[readIntoRequests_] = [];
	    }
	    get closed() {
	        if (!isReadableStreamBYOBReader(this)) {
	            return Promise.reject(new TypeError());
	        }
	        return this[closedPromise_].promise;
	    }
	    cancel(reason) {
	        if (!isReadableStreamBYOBReader(this)) {
	            return Promise.reject(new TypeError());
	        }
	        const stream = this[ownerReadableStream_];
	        if (stream === undefined) {
	            return Promise.reject(new TypeError("Reader is not associated with a stream"));
	        }
	        return readableStreamCancel(stream, reason);
	    }
	    read(view) {
	        if (!isReadableStreamBYOBReader(this)) {
	            return Promise.reject(new TypeError());
	        }
	        if (this[ownerReadableStream_] === undefined) {
	            return Promise.reject(new TypeError("Reader is not associated with a stream"));
	        }
	        if (!ArrayBuffer.isView(view)) {
	            return Promise.reject(new TypeError("view argument must be a valid ArrayBufferView"));
	        }
	        if (view.byteLength === 0) {
	            return Promise.reject(new TypeError("supplied buffer view must be > 0 bytes"));
	        }
	        return readableStreamBYOBReaderRead(this, view, true);
	    }
	    releaseLock() {
	        if (!isReadableStreamBYOBReader(this)) {
	            throw new TypeError();
	        }
	        if (this[ownerReadableStream_] === undefined) {
	            throw new TypeError("Reader is not associated with a stream");
	        }
	        if (this[readIntoRequests_].length > 0) {
	            throw new TypeError();
	        }
	        readableStreamReaderGenericRelease(this);
	    }
	}

	class SDReadableStream {
	    constructor(underlyingSource = {}, strategy = {}) {
	        initializeReadableStream(this);
	        const sizeFunc = strategy.size;
	        const stratHWM = strategy.highWaterMark;
	        const sourceType = underlyingSource.type;
	        if (sourceType === undefined) {
	            const sizeAlgorithm = makeSizeAlgorithmFromSizeFunction(sizeFunc);
	            const highWaterMark = validateAndNormalizeHighWaterMark(stratHWM === undefined ? 1 : stratHWM);
	            setUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
	        }
	        else if (String(sourceType) === "bytes") {
	            if (sizeFunc !== undefined) {
	                throw new RangeError("bytes streams cannot have a strategy with a `size` field");
	            }
	            const highWaterMark = validateAndNormalizeHighWaterMark(stratHWM === undefined ? 0 : stratHWM);
	            setUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
	        }
	        else {
	            throw new RangeError("The underlying source's `type` field must be undefined or 'bytes'");
	        }
	    }
	    get locked() {
	        return isReadableStreamLocked(this);
	    }
	    getReader(options) {
	        if (!isReadableStream(this)) {
	            throw new TypeError();
	        }
	        if (options === undefined) {
	            options = {};
	        }
	        const { mode } = options;
	        if (mode === undefined) {
	            return new ReadableStreamDefaultReader(this);
	        }
	        else if (String(mode) === "byob") {
	            return new SDReadableStreamBYOBReader(this);
	        }
	        throw RangeError("mode option must be undefined or `byob`");
	    }
	    cancel(reason) {
	        if (!isReadableStream(this)) {
	            return Promise.reject(new TypeError());
	        }
	        if (isReadableStreamLocked(this)) {
	            return Promise.reject(new TypeError("Cannot cancel a locked stream"));
	        }
	        return readableStreamCancel(this, reason);
	    }
	    tee() {
	        return readableStreamTee(this, false);
	    }
	    pipeThrough(transform, options = {}) {
	        const { readable, writable } = transform;
	        if (!isReadableStream(this)) {
	            throw new TypeError();
	        }
	        if (!isWritableStream(writable)) {
	            throw new TypeError("writable must be a WritableStream");
	        }
	        if (!isReadableStream(readable)) {
	            throw new TypeError("readable must be a ReadableStream");
	        }
	        if (options.signal !== undefined && !isAbortSignal(options.signal)) {
	            throw new TypeError("options.signal must be an AbortSignal instance");
	        }
	        if (isReadableStreamLocked(this)) {
	            throw new TypeError("Cannot pipeThrough on a locked stream");
	        }
	        if (isWritableStreamLocked(writable)) {
	            throw new TypeError("Cannot pipeThrough to a locked stream");
	        }
	        const pipeResult = pipeTo(this, writable, options);
	        pipeResult.catch(() => { });
	        return readable;
	    }
	    pipeTo(dest, options = {}) {
	        if (!isReadableStream(this)) {
	            return Promise.reject(new TypeError());
	        }
	        if (!isWritableStream(dest)) {
	            return Promise.reject(new TypeError("destination must be a WritableStream"));
	        }
	        if (options.signal !== undefined && !isAbortSignal(options.signal)) {
	            return Promise.reject(new TypeError("options.signal must be an AbortSignal instance"));
	        }
	        if (isReadableStreamLocked(this)) {
	            return Promise.reject(new TypeError("Cannot pipe from a locked stream"));
	        }
	        if (isWritableStreamLocked(dest)) {
	            return Promise.reject(new TypeError("Cannot pipe to a locked stream"));
	        }
	        return pipeTo(this, dest, options);
	    }
	}
	function createReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
	    if (highWaterMark === undefined) {
	        highWaterMark = 1;
	    }
	    if (sizeAlgorithm === undefined) {
	        sizeAlgorithm = () => 1;
	    }
	    const stream = Object.create(SDReadableStream.prototype);
	    initializeReadableStream(stream);
	    const controller = Object.create(ReadableStreamDefaultController.prototype);
	    setUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
	    return stream;
	}
	function createReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
	    if (highWaterMark === undefined) {
	        highWaterMark = 0;
	    }
	    if (autoAllocateChunkSize !== undefined) {
	        if (!isInteger(autoAllocateChunkSize) || autoAllocateChunkSize <= 0) {
	            throw new RangeError("autoAllocateChunkSize must be a positive, finite integer");
	        }
	    }
	    const stream = Object.create(SDReadableStream.prototype);
	    initializeReadableStream(stream);
	    const controller = Object.create(ReadableByteStreamController.prototype);
	    setUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
	    return stream;
	}
	function readableStreamTee(stream, cloneForBranch2) {
	    if (!isReadableStream(stream)) {
	        throw new TypeError();
	    }
	    const reader = new ReadableStreamDefaultReader(stream);
	    let closedOrErrored = false;
	    let canceled1 = false;
	    let canceled2 = false;
	    let reason1;
	    let reason2;
	    let branch1;
	    let branch2;
	    let cancelResolve;
	    const cancelPromise = new Promise(resolve => cancelResolve = resolve);
	    const pullAlgorithm = () => {
	        return readableStreamDefaultReaderRead(reader).then(({ value, done }) => {
	            if (done && !closedOrErrored) {
	                if (!canceled1) {
	                    readableStreamDefaultControllerClose(branch1[readableStreamController_]);
	                }
	                if (!canceled2) {
	                    readableStreamDefaultControllerClose(branch2[readableStreamController_]);
	                }
	                closedOrErrored = true;
	            }
	            if (closedOrErrored) {
	                return;
	            }
	            const value1 = value;
	            let value2 = value;
	            if (!canceled1) {
	                readableStreamDefaultControllerEnqueue(branch1[readableStreamController_], value1);
	            }
	            if (!canceled2) {
	                if (cloneForBranch2) {
	                    value2 = cloneValue(value2);
	                }
	                readableStreamDefaultControllerEnqueue(branch2[readableStreamController_], value2);
	            }
	        });
	    };
	    const cancel1Algorithm = (reason) => {
	        canceled1 = true;
	        reason1 = reason;
	        if (canceled2) {
	            const cancelResult = readableStreamCancel(stream, [reason1, reason2]);
	            cancelResolve(cancelResult);
	        }
	        return cancelPromise;
	    };
	    const cancel2Algorithm = (reason) => {
	        canceled2 = true;
	        reason2 = reason;
	        if (canceled1) {
	            const cancelResult = readableStreamCancel(stream, [reason1, reason2]);
	            cancelResolve(cancelResult);
	        }
	        return cancelPromise;
	    };
	    const startAlgorithm = () => undefined;
	    branch1 = createReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
	    branch2 = createReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
	    reader[closedPromise_].promise.catch(error => {
	        if (!closedOrErrored) {
	            readableStreamDefaultControllerError(branch1[readableStreamController_], error);
	            readableStreamDefaultControllerError(branch2[readableStreamController_], error);
	            closedOrErrored = true;
	        }
	    });
	    return [branch1, branch2];
	}

	class WritableStreamDefaultController {
	    constructor() {
	        throw new TypeError();
	    }
	    error(e) {
	        if (!isWritableStreamDefaultController(this)) {
	            throw new TypeError();
	        }
	        const state = this[controlledWritableStream_][state_];
	        if (state !== "writable") {
	            return;
	        }
	        writableStreamDefaultControllerError(this, e);
	    }
	    [(abortSteps_)](reason) {
	        const result = this[abortAlgorithm_](reason);
	        writableStreamDefaultControllerClearAlgorithms(this);
	        return result;
	    }
	    [errorSteps_]() {
	        resetQueue(this);
	    }
	}
	function setUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
	    const controller = Object.create(WritableStreamDefaultController.prototype);
	    const startAlgorithm = function () {
	        return invokeOrNoop(underlyingSink, "start", [controller]);
	    };
	    const writeAlgorithm = createAlgorithmFromUnderlyingMethod(underlyingSink, "write", [controller]);
	    const closeAlgorithm = createAlgorithmFromUnderlyingMethod(underlyingSink, "close", []);
	    const abortAlgorithm = createAlgorithmFromUnderlyingMethod(underlyingSink, "abort", []);
	    setUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
	}

	class WritableStream {
	    constructor(sink = {}, strategy = {}) {
	        initializeWritableStream(this);
	        const sizeFunc = strategy.size;
	        const stratHWM = strategy.highWaterMark;
	        if (sink.type !== undefined) {
	            throw new RangeError("The type of an underlying sink must be undefined");
	        }
	        const sizeAlgorithm = makeSizeAlgorithmFromSizeFunction(sizeFunc);
	        const highWaterMark = validateAndNormalizeHighWaterMark(stratHWM === undefined ? 1 : stratHWM);
	        setUpWritableStreamDefaultControllerFromUnderlyingSink(this, sink, highWaterMark, sizeAlgorithm);
	    }
	    get locked() {
	        if (!isWritableStream(this)) {
	            throw new TypeError();
	        }
	        return isWritableStreamLocked(this);
	    }
	    abort(reason) {
	        if (!isWritableStream(this)) {
	            return Promise.reject(new TypeError());
	        }
	        if (isWritableStreamLocked(this)) {
	            return Promise.reject(new TypeError("Cannot abort a locked stream"));
	        }
	        return writableStreamAbort(this, reason);
	    }
	    getWriter() {
	        if (!isWritableStream(this)) {
	            throw new TypeError();
	        }
	        return new WritableStreamDefaultWriter(this);
	    }
	}
	function createWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
	    if (highWaterMark === undefined) {
	        highWaterMark = 1;
	    }
	    if (sizeAlgorithm === undefined) {
	        sizeAlgorithm = () => 1;
	    }
	    const stream = Object.create(WritableStream.prototype);
	    initializeWritableStream(stream);
	    const controller = Object.create(WritableStreamDefaultController.prototype);
	    setUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
	    return stream;
	}

	const backpressure_$1 = Symbol("backpressure_");
	const backpressureChangePromise_ = Symbol("backpressureChangePromise_");
	const readable_ = Symbol("readable_");
	const transformStreamController_ = Symbol("transformStreamController_");
	const writable_ = Symbol("writable_");
	const controlledTransformStream_ = Symbol("controlledTransformStream_");
	const flushAlgorithm_ = Symbol("flushAlgorithm_");
	const transformAlgorithm_ = Symbol("transformAlgorithm_");
	function isTransformStream(value) {
	    if (typeof value !== "object" || value === null) {
	        return false;
	    }
	    return transformStreamController_ in value;
	}
	function initializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
	    const startAlgorithm = function () {
	        return startPromise;
	    };
	    const writeAlgorithm = function (chunk) {
	        return transformStreamDefaultSinkWriteAlgorithm(stream, chunk);
	    };
	    const abortAlgorithm = function (reason) {
	        return transformStreamDefaultSinkAbortAlgorithm(stream, reason);
	    };
	    const closeAlgorithm = function () {
	        return transformStreamDefaultSinkCloseAlgorithm(stream);
	    };
	    stream[writable_] = createWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
	    const pullAlgorithm = function () {
	        return transformStreamDefaultSourcePullAlgorithm(stream);
	    };
	    const cancelAlgorithm = function (reason) {
	        transformStreamErrorWritableAndUnblockWrite(stream, reason);
	        return Promise.resolve(undefined);
	    };
	    stream[readable_] = createReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
	    stream[backpressure_$1] = undefined;
	    stream[backpressureChangePromise_] = undefined;
	    transformStreamSetBackpressure(stream, true);
	    stream[transformStreamController_] = undefined;
	}
	function transformStreamError(stream, error) {
	    readableStreamDefaultControllerError(stream[readable_][readableStreamController_], error);
	    transformStreamErrorWritableAndUnblockWrite(stream, error);
	}
	function transformStreamErrorWritableAndUnblockWrite(stream, error) {
	    transformStreamDefaultControllerClearAlgorithms(stream[transformStreamController_]);
	    writableStreamDefaultControllerErrorIfNeeded(stream[writable_][writableStreamController_], error);
	    if (stream[backpressure_$1]) {
	        transformStreamSetBackpressure(stream, false);
	    }
	}
	function transformStreamSetBackpressure(stream, backpressure) {
	    if (stream[backpressure_$1] !== undefined) {
	        stream[backpressureChangePromise_].resolve(undefined);
	    }
	    stream[backpressureChangePromise_] = createControlledPromise();
	    stream[backpressure_$1] = backpressure;
	}
	function isTransformStreamDefaultController(value) {
	    if (typeof value !== "object" || value === null) {
	        return false;
	    }
	    return controlledTransformStream_ in value;
	}
	function setUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
	    controller[controlledTransformStream_] = stream;
	    stream[transformStreamController_] = controller;
	    controller[transformAlgorithm_] = transformAlgorithm;
	    controller[flushAlgorithm_] = flushAlgorithm;
	}
	function transformStreamDefaultControllerClearAlgorithms(controller) {
	    controller[transformAlgorithm_] = undefined;
	    controller[flushAlgorithm_] = undefined;
	}
	function transformStreamDefaultControllerEnqueue(controller, chunk) {
	    const stream = controller[controlledTransformStream_];
	    const readableController = stream[readable_][readableStreamController_];
	    if (!readableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
	        throw new TypeError();
	    }
	    try {
	        readableStreamDefaultControllerEnqueue(readableController, chunk);
	    }
	    catch (error) {
	        transformStreamErrorWritableAndUnblockWrite(stream, error);
	        throw stream[readable_][storedError_];
	    }
	    const backpressure = readableStreamDefaultControllerHasBackpressure(readableController);
	    if (backpressure !== stream[backpressure_$1]) {
	        transformStreamSetBackpressure(stream, true);
	    }
	}
	function transformStreamDefaultControllerError(controller, error) {
	    transformStreamError(controller[controlledTransformStream_], error);
	}
	function transformStreamDefaultControllerPerformTransform(controller, chunk) {
	    const transformPromise = controller[transformAlgorithm_](chunk);
	    return transformPromise.catch(error => {
	        transformStreamError(controller[controlledTransformStream_], error);
	        throw error;
	    });
	}
	function transformStreamDefaultControllerTerminate(controller) {
	    const stream = controller[controlledTransformStream_];
	    const readableController = stream[readable_][readableStreamController_];
	    if (readableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
	        readableStreamDefaultControllerClose(readableController);
	    }
	    const error = new TypeError("The transform stream has been terminated");
	    transformStreamErrorWritableAndUnblockWrite(stream, error);
	}
	function transformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
	    const controller = stream[transformStreamController_];
	    if (stream[backpressure_$1]) {
	        const backpressureChangePromise = stream[backpressureChangePromise_];
	        return backpressureChangePromise.promise.then(_ => {
	            const writable = stream[writable_];
	            const state = writable[state_];
	            if (state === "erroring") {
	                throw writable[storedError_];
	            }
	            return transformStreamDefaultControllerPerformTransform(controller, chunk);
	        });
	    }
	    return transformStreamDefaultControllerPerformTransform(controller, chunk);
	}
	function transformStreamDefaultSinkAbortAlgorithm(stream, reason) {
	    transformStreamError(stream, reason);
	    return Promise.resolve(undefined);
	}
	function transformStreamDefaultSinkCloseAlgorithm(stream) {
	    const readable = stream[readable_];
	    const controller = stream[transformStreamController_];
	    const flushPromise = controller[flushAlgorithm_]();
	    transformStreamDefaultControllerClearAlgorithms(controller);
	    return flushPromise.then(_ => {
	        if (readable[state_] === "errored") {
	            throw readable[storedError_];
	        }
	        const readableController = readable[readableStreamController_];
	        if (readableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
	            readableStreamDefaultControllerClose(readableController);
	        }
	    }, error => {
	        transformStreamError(stream, error);
	        throw readable[storedError_];
	    });
	}
	function transformStreamDefaultSourcePullAlgorithm(stream) {
	    transformStreamSetBackpressure(stream, false);
	    return stream[backpressureChangePromise_].promise;
	}

	class TransformStreamDefaultController {
	    constructor() {
	        throw new TypeError();
	    }
	    get desiredSize() {
	        if (!isTransformStreamDefaultController(this)) {
	            throw new TypeError();
	        }
	        const readableController = this[controlledTransformStream_][readable_][readableStreamController_];
	        return readableStreamDefaultControllerGetDesiredSize(readableController);
	    }
	    enqueue(chunk) {
	        if (!isTransformStreamDefaultController(this)) {
	            throw new TypeError();
	        }
	        transformStreamDefaultControllerEnqueue(this, chunk);
	    }
	    error(reason) {
	        if (!isTransformStreamDefaultController(this)) {
	            throw new TypeError();
	        }
	        transformStreamDefaultControllerError(this, reason);
	    }
	    terminate() {
	        if (!isTransformStreamDefaultController(this)) {
	            throw new TypeError();
	        }
	        transformStreamDefaultControllerTerminate(this);
	    }
	}

	class TransformStream {
	    constructor(transformer = {}, writableStrategy = {}, readableStrategy = {}) {
	        const writableSizeFunction = writableStrategy.size;
	        const writableHighWaterMark = writableStrategy.highWaterMark;
	        const readableSizeFunction = readableStrategy.size;
	        const readableHighWaterMark = readableStrategy.highWaterMark;
	        const writableType = transformer.writableType;
	        if (writableType !== undefined) {
	            throw new RangeError("The transformer's `writableType` field must be undefined");
	        }
	        const writableSizeAlgorithm = makeSizeAlgorithmFromSizeFunction(writableSizeFunction);
	        const writableHWM = validateAndNormalizeHighWaterMark(writableHighWaterMark === undefined ? 1 : writableHighWaterMark);
	        const readableType = transformer.readableType;
	        if (readableType !== undefined) {
	            throw new RangeError("The transformer's `readableType` field must be undefined");
	        }
	        const readableSizeAlgorithm = makeSizeAlgorithmFromSizeFunction(readableSizeFunction);
	        const readableHWM = validateAndNormalizeHighWaterMark(readableHighWaterMark === undefined ? 0 : readableHighWaterMark);
	        const startPromise = createControlledPromise();
	        initializeTransformStream(this, startPromise.promise, writableHWM, writableSizeAlgorithm, readableHWM, readableSizeAlgorithm);
	        setUpTransformStreamDefaultControllerFromTransformer(this, transformer);
	        const startResult = invokeOrNoop(transformer, "start", [this[transformStreamController_]]);
	        startPromise.resolve(startResult);
	    }
	    get readable() {
	        if (!isTransformStream(this)) {
	            throw new TypeError();
	        }
	        return this[readable_];
	    }
	    get writable() {
	        if (!isTransformStream(this)) {
	            throw new TypeError();
	        }
	        return this[writable_];
	    }
	}
	function setUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
	    const controller = Object.create(TransformStreamDefaultController.prototype);
	    let transformAlgorithm;
	    const transformMethod = transformer.transform;
	    if (transformMethod !== undefined) {
	        if (typeof transformMethod !== "function") {
	            throw new TypeError("`transform` field of the transformer must be a function");
	        }
	        transformAlgorithm = (chunk) => promiseCall(transformMethod, transformer, [chunk, controller]);
	    }
	    else {
	        transformAlgorithm = function (chunk) {
	            try {
	                transformStreamDefaultControllerEnqueue(controller, chunk);
	            }
	            catch (error) {
	                return Promise.reject(error);
	            }
	            return Promise.resolve(undefined);
	        };
	    }
	    const flushAlgorithm = createAlgorithmFromUnderlyingMethod(transformer, "flush", [controller]);
	    setUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
	}

	class ByteLengthQueuingStrategy {
	    constructor(options) {
	        this.highWaterMark = options.highWaterMark;
	    }
	    size(chunk) {
	        return chunk.byteLength;
	    }
	}
	class CountQueuingStrategy {
	    constructor(options) {
	        this.highWaterMark = options.highWaterMark;
	    }
	    size() {
	        return 1;
	    }
	}

	exports.ReadableStream = SDReadableStream;
	exports.WritableStream = WritableStream;
	exports.TransformStream = TransformStream;
	exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
	exports.CountQueuingStrategy = CountQueuingStrategy;
	exports.internal_createReadableStream = createReadableStream;
	exports.internal_createReadableByteStream = createReadableByteStream;
	exports.internal_readableStreamTee = readableStreamTee;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
